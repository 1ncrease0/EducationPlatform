
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">SkillForge/cmd/main.go (0.0%)</option>
				
				<option value="file1">SkillForge/internal/app/app.go (0.0%)</option>
				
				<option value="file2">SkillForge/internal/app/server/server.go (0.0%)</option>
				
				<option value="file3">SkillForge/internal/config/config.go (0.0%)</option>
				
				<option value="file4">SkillForge/internal/delivery/http/controllers/auth.go (53.4%)</option>
				
				<option value="file5">SkillForge/internal/delivery/http/controllers/course.go (24.5%)</option>
				
				<option value="file6">SkillForge/internal/delivery/http/controllers/lesson.go (34.7%)</option>
				
				<option value="file7">SkillForge/internal/delivery/http/controllers/middleware.go (34.4%)</option>
				
				<option value="file8">SkillForge/internal/delivery/http/controllers/status.go (0.0%)</option>
				
				<option value="file9">SkillForge/internal/delivery/http/router.go (0.0%)</option>
				
				<option value="file10">SkillForge/internal/service/auth/auth.go (76.5%)</option>
				
				<option value="file11">SkillForge/internal/service/auth/jwt.go (69.6%)</option>
				
				<option value="file12">SkillForge/internal/service/course/course.go (40.7%)</option>
				
				<option value="file13">SkillForge/internal/service/lesson/lesson.go (52.1%)</option>
				
				<option value="file14">SkillForge/internal/storage/elastic/course_search.go (0.0%)</option>
				
				<option value="file15">SkillForge/internal/storage/elastic/elasticsearch.go (0.0%)</option>
				
				<option value="file16">SkillForge/internal/storage/minio_storage/course_logos.go (0.0%)</option>
				
				<option value="file17">SkillForge/internal/storage/minio_storage/lesson_media.go (0.0%)</option>
				
				<option value="file18">SkillForge/internal/storage/minio_storage/minio.go (0.0%)</option>
				
				<option value="file19">SkillForge/internal/storage/postgres/content_postgres.go (85.3%)</option>
				
				<option value="file20">SkillForge/internal/storage/postgres/course_postgres.go (46.7%)</option>
				
				<option value="file21">SkillForge/internal/storage/postgres/course_rating.go (0.0%)</option>
				
				<option value="file22">SkillForge/internal/storage/postgres/lesson_postgres.go (47.7%)</option>
				
				<option value="file23">SkillForge/internal/storage/postgres/postgres.go (25.0%)</option>
				
				<option value="file24">SkillForge/internal/storage/postgres/subscriptions_postgres.go (0.0%)</option>
				
				<option value="file25">SkillForge/internal/storage/postgres/tokens_postgres.go (82.9%)</option>
				
				<option value="file26">SkillForge/internal/storage/postgres/user_postgres.go (0.0%)</option>
				
				<option value="file27">SkillForge/pkg/custom_serializer/json/myjson.go (65.7%)</option>
				
				<option value="file28">SkillForge/pkg/custom_serializer/toml/mytoml.go (54.7%)</option>
				
				<option value="file29">SkillForge/pkg/logger/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "SkillForge/internal/app"
        "SkillForge/internal/config"
        "github.com/gin-gonic/gin"
)

func main() <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        cfg := config.MustLoad()
        app.Run(cfg)

}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "SkillForge/internal/app/server"
        "SkillForge/internal/config"
        "SkillForge/internal/delivery/http"
        "SkillForge/internal/service"
        "SkillForge/internal/service/auth"
        "SkillForge/internal/service/course"
        "SkillForge/internal/service/lesson"
        "SkillForge/internal/storage/elastic"
        "SkillForge/internal/storage/minio_storage"
        "SkillForge/internal/storage/postgres"
        "SkillForge/pkg/logger"
        "context"
        "os"
        "os/signal"
        "syscall"
)

func Run(cfg *config.Config) <span class="cov0" title="0">{

        log := logger.New(cfg.Env)
        log.Info("Starting with Env: " + cfg.Env)

        pg, err := postgres.NewPostgresPool(cfg.Postgres.User, cfg.Postgres.Password, cfg.Postgres.Host, cfg.Postgres.Port, cfg.Postgres.DBName)
        if err != nil </span><span class="cov0" title="0">{
                log.FatalErr("error connecting to database", err)
        }</span>
        <span class="cov0" title="0">defer pg.Close()

        es, err := elastic.NewElasticClient(cfg.ES.Password, cfg.ES.Hosts)
        if err != nil </span><span class="cov0" title="0">{
                log.FatalErr("error connecting to elastic", err)
        }</span>

        <span class="cov0" title="0">minio, err := minio_storage.NewMinioStorage(cfg.Minio.Endpoint, cfg.Minio.AccessKey, cfg.Minio.SecretKey, cfg.Minio.UseSSL)
        if err != nil </span><span class="cov0" title="0">{
                log.FatalErr("error connecting to minio storage", err)
        }</span>

        <span class="cov0" title="0">logoStorage, err := minio_storage.NewLogoStorage(minio, cfg.Minio.Buckets["course_logos"].Name, cfg.Minio.Buckets["course_logos"].PresignTTL)
        if err != nil </span><span class="cov0" title="0">{
                log.FatalErr("error connecting to minio storage", err)
        }</span>
        <span class="cov0" title="0">lessonMediaStorage, err := minio_storage.NewLessonStorage(minio, cfg.Minio.Buckets["lesson_media"].Name, cfg.Minio.Buckets["lesson_media"].PresignTTL)
        if err != nil </span><span class="cov0" title="0">{
                log.FatalErr("error connecting to minio storage", err)
        }</span>
        <span class="cov0" title="0">courseES := elastic.NewCourseSearchRepository(es, elastic.CourseIndex)
        err = courseES.CreateIndexIfNotExist(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.FatalErr("error creating index", err)
        }</span>

        <span class="cov0" title="0">tokenRepo := postgres.NewTokensPostgres(pg.Pool)
        courseRepo := postgres.NewCoursePostgres(pg.Pool)
        userRepo := postgres.NewUserPostgres(pg.Pool)
        lessonRepo := postgres.NewLessonPostgres(pg.Pool)
        enrollmentsRepo := postgres.NewSubscriptionPostgres(pg.Pool)
        ratingRepo := postgres.NewCourseRatingPostgres(pg.Pool)

        jwtManager := auth.NewJWTManager(cfg.JWT.SecretKey, "//", cfg.JWT.AccessTTL, cfg.JWT.RefreshTTL)
        authService := auth.NewAuthService(log, jwtManager, userRepo, tokenRepo)

        courseService := course.NewCourseService(log, courseRepo, courseES, logoStorage, lessonRepo, userRepo, enrollmentsRepo, ratingRepo)
        lessonService := lesson.NewLessonService(log, lessonRepo, courseRepo, lessonMediaStorage)
        u := service.Collection{AuthService: authService, CourseService: courseService, LessonService: lessonService}

        r := http.InitRoutes(log, u)

        srv := server.New(cfg.HTTPServer.Address, cfg.HTTPServer.Timeout, cfg.HTTPServer.IdleTimeout, r)
        srv.Start()
        interrupt := make(chan os.Signal, 1)
        signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)

        select </span>{
        case s := &lt;-interrupt:<span class="cov0" title="0">
                log.Info("app signal: %s" + s.String())</span>
        case err := &lt;-srv.Notify():<span class="cov0" title="0">
                log.ErrorErr("err", err)</span>
        }
        <span class="cov0" title="0">err = srv.Shutdown()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("err", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package server

import (
        "context"
        "net/http"
        "time"
)

type Server struct {
        httpServer *http.Server
        notify     chan error
}

func New(address string, timeout time.Duration, idleTimeout time.Duration, handler http.Handler) *Server <span class="cov0" title="0">{
        httpServer := &amp;http.Server{
                Addr:         address,
                Handler:      handler,
                ReadTimeout:  timeout,
                WriteTimeout: timeout,
                IdleTimeout:  idleTimeout,
        }

        s := &amp;Server{httpServer: httpServer}
        return s
}</span>

func (s *Server) Start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                s.notify &lt;- s.httpServer.ListenAndServe()
                close(s.notify)
        }</span>()
}

func (s *Server) Notify() &lt;-chan error <span class="cov0" title="0">{
        return s.notify
}</span>

func (s *Server) Shutdown() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()
        return s.httpServer.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "log"
        "os"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        Env        string     `yaml:"env" env-default:"local"`
        HTTPServer HTTPServer `yaml:"http_server"`
        Postgres   Postgres   `yaml:"postgres"`
        JWT        JWT        `yaml:"jwt"`
        ES         ES         `yaml:"elasticsearch"`
        Minio      Minio      `yaml:"minio"`
}

type Minio struct {
        Endpoint  string                  `yaml:"endpoint" env-default:"minio:9000"`
        AccessKey string                  `yaml:"access_key"`
        SecretKey string                  `yaml:"secret_key"`
        UseSSL    bool                    `yaml:"use_ssl"`
        Buckets   map[string]BucketConfig `yaml:"buckets"`
}

type BucketConfig struct {
        Name       string        `yaml:"name"`
        PresignTTL time.Duration `yaml:"presign_ttl"`
}

type ES struct {
        Hosts    []string `yaml:"hosts"`
        Index    string   `yaml:"index"`
        Password string   `yaml:"password"`
}

type JWT struct {
        SecretKey  string        `yaml:"secret_key"`
        AccessTTL  time.Duration `yaml:"access_token_ttl"`
        RefreshTTL time.Duration `yaml:"refresh_token_ttl"`
}

type Postgres struct {
        Host     string `yaml:"host"`
        Port     string `yaml:"port"`
        User     string `yaml:"user"`
        Password string `yaml:"password"`
        DBName   string `yaml:"dbname"`
}

type HTTPServer struct {
        Address     string        `yaml:"address" env-default:"localhost:8081"`
        Timeout     time.Duration `yaml:"timeout" env-default:"5s"`
        IdleTimeout time.Duration `yaml:"idle_timeout" env-default:"60s"`
}

func MustLoad() *Config <span class="cov0" title="0">{
        configPath := os.Getenv("CONFIG_PATH")
        if configPath == "" </span><span class="cov0" title="0">{

                log.Fatal("CONFIG_PATH is not set")
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Fatalf("Config file not exist: %s", configPath)
        }</span>

        <span class="cov0" title="0">var cfg Config

        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Can not read config file %s", err)
        }</span>

        <span class="cov0" title="0">return &amp;cfg</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "SkillForge/pkg/logger"
        "context"
        "errors"
        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "net/http"
)

type AuthService interface {
        CreateUser(ctx context.Context, user models.User) (*models.User, error)
        LoginUser(ctx context.Context, username, password string) (accessToken, refreshToken string, err error)
        ParseToken(ctx context.Context, token string) (*jwt.Token, error)
        IsAccessToken(ctx context.Context, token *jwt.Token) bool
        AccessClaims(ctx context.Context, token string) (userID uuid.UUID, roles []string, err error)
        User(ctx context.Context, id uuid.UUID) (*models.User, error)
        RefreshTokens(ctx context.Context, token string) (*models.TokenPair, error)
}

type AuthHandler struct {
        AuthService AuthService
        log         logger.Log
}

func NewAuthHandler(l logger.Log, auth AuthService) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{
                AuthService: auth,
                log:         l,
        }
}</span>

type meResponse struct {
        UserId   string   `json:"userId"`
        Username string   `json:"username" binding:"required"`
        Email    string   `json:"email" binding:"required"`
        Role     []string `json:"role" binding:"required"`
}

func (h *AuthHandler) Me(c *gin.Context) <span class="cov8" title="1">{
        userIDVal, exists := c.Get(ClientIDCtx)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>
        <span class="cov8" title="1">userID, ok := userIDVal.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user id"})
                return
        }</span>
        <span class="cov8" title="1">user, err := h.AuthService.User(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                h.log.ErrorErr("error retrieving user", err, c)
                return
        }</span>

        <span class="cov8" title="1">resp := meResponse{
                UserId:   userID.String(),
                Username: user.Username,
                Email:    user.Email,
                Role:     user.Roles,
        }
        c.JSON(http.StatusOK, resp)</span>
}

type registerRequest struct {
        Username string   `json:"username" binding:"required"`
        Password string   `json:"password" binding:"required"`
        Email    string   `json:"email" binding:"required"`
        Role     []string `json:"role" binding:"required"`
}

func (h *AuthHandler) Register(c *gin.Context) <span class="cov8" title="1">{
        var input registerRequest
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">user := models.User{
                Username: input.Username,
                Password: input.Password,
                Email:    input.Email,
                Roles:    make([]string, 0),
        }
        for _, role := range input.Role </span><span class="cov8" title="1">{
                user.Roles = append(user.Roles, role)
        }</span>

        <span class="cov8" title="1">_, err := h.AuthService.CreateUser(c.Request.Context(), user)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, app_errors.ErrUserExists) || errors.Is(err, app_errors.ErrIncorrectPassword) </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                h.log.ErrorErr("error handling register user", err, c)

                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{"message": "registration success"})</span>
}

type loginRequest struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
}

type loginResponse struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
}

func (h *AuthHandler) Login(c *gin.Context) <span class="cov8" title="1">{
        var input loginRequest
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">accessToken, refreshToken, err := h.AuthService.LoginUser(c.Request.Context(), input.Username, input.Password)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, app_errors.ErrUserNotFound) || errors.Is(err, app_errors.ErrIncorrectPassword) </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                h.log.ErrorErr("Error handling login user", err, c)
                return</span>
        }

        <span class="cov8" title="1">response := loginResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        }
        c.JSON(http.StatusOK, response)</span>

}

type tokenRefreshRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
}

type tokenRefreshResponse struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
}

func (h *AuthHandler) Refresh(c *gin.Context) <span class="cov0" title="0">{
        var input tokenRefreshRequest
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">tokenPair, err := h.AuthService.RefreshTokens(c.Request.Context(), input.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, app_errors.ErrUserNotFound) || errors.Is(err, app_errors.ErrTokenExpired) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, tokenRefreshResponse{
                AccessToken:  tokenPair.AccessToken.Raw,
                RefreshToken: tokenPair.RefreshToken.Raw,
        })</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controllers

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "SkillForge/pkg/logger"
        "context"
        "io"
        "mime"
        "net/http"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type CourseService interface {
        CreateCourse(ctx context.Context, course models.Course) (uuid.UUID, error)
        Publish(ctx context.Context, id uuid.UUID, authorID uuid.UUID) error
        Hide(ctx context.Context, id uuid.UUID, authorID uuid.UUID) error
        CoursesPreview(ctx context.Context, count int, offset int) ([]models.CoursePreview, int, error)
        SearchCoursesPreview(ctx context.Context, query string, count int, offset int) ([]models.CoursePreview, int, error)
        UploadCourseLogo(ctx context.Context, courseID, authorID uuid.UUID, filename string, reader io.Reader, size int64, contentType string) (string, error)
        CourseByID(ctx context.Context, id uuid.UUID) (*models.CoursePreview, error)
        Subscribe(ctx context.Context, courseID, userID uuid.UUID) error
        GetSubscribedCourses(ctx context.Context, userID uuid.UUID) ([]models.CoursePreview, error)
        GetMyCourses(ctx context.Context, authorID uuid.UUID) ([]models.CoursePreview, error)
        GetCourseStatus(ctx context.Context, courseID uuid.UUID) (string, error)
        RateCourse(ctx context.Context, courseID, userID uuid.UUID) error
        UnrateCourse(ctx context.Context, courseID, userID uuid.UUID) error
        GetRatingStatus(ctx context.Context, userID uuid.UUID) (map[uuid.UUID]bool, error)
}

type CourseHandler struct {
        CourseService CourseService
        log           logger.Log
}

func NewCourseHandler(l logger.Log, courseService CourseService) *CourseHandler <span class="cov8" title="1">{
        return &amp;CourseHandler{
                CourseService: courseService,
                log:           l,
        }
}</span>

func (h *CourseHandler) CourseByID(c *gin.Context) <span class="cov0" title="0">{
        courseIDStr := c.Param("course_id")
        courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.log.ErrorErr("err", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov0" title="0">preview, err := h.CourseService.CourseByID(c.Request.Context(), courseID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, preview)</span>
}

func (h *CourseHandler) UploadCourseLogo(c *gin.Context) <span class="cov8" title="1">{
        courseIDParam := c.Param("course_id")
        courseID, err := uuid.Parse(courseIDParam)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>
        <span class="cov8" title="1">authorIDValue, exists := c.Get(ClientIDCtx)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov8" title="1">authorID, ok := authorIDValue.(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user_id in context"})
                return
        }</span>

        <span class="cov8" title="1">fileHeader, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "file is required"})
                return
        }</span>
        <span class="cov8" title="1">file, err := fileHeader.Open()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "cannot open uploaded file"})
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        contentType := fileHeader.Header.Get("CourseContent-Type")
        if contentType == "" </span><span class="cov8" title="1">{
                contentType = mime.TypeByExtension(strings.ToLower(filepath.Ext(fileHeader.Filename)))
        }</span>

        <span class="cov8" title="1">url, err := h.CourseService.UploadCourseLogo(
                c.Request.Context(),
                courseID,
                authorID,
                fileHeader.Filename,
                file,
                fileHeader.Size,
                contentType,
        )
        if err != nil </span><span class="cov8" title="1">{
                switch err </span>{
                case app_errors.ErrNotCourseAuthor:<span class="cov8" title="1">
                        c.JSON(http.StatusForbidden, gin.H{"error": err.Error()})</span>
                case app_errors.ErrFileSize:<span class="cov0" title="0">
                        c.JSON(http.StatusRequestEntityTooLarge, gin.H{"error": err.Error()})</span>
                case app_errors.ErrNotImage:<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})</span>
                default:<span class="cov0" title="0">
                        h.log.ErrorErr("UploadCourseLogo failed", err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "upload failed"})</span>
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "status": "ok",
                "url":    url,
        })</span>
}

func (h *CourseHandler) ListCoursePreview(c *gin.Context) <span class="cov8" title="1">{
        ctx := c.Request.Context()
        limit := 10
        if s := c.Query("limit"); s != "" </span><span class="cov0" title="0">{
                v, err := strconv.Atoi(s)
                if err != nil || v &lt;= 0 </span><span class="cov0" title="0">{
                        h.log.ErrorErr("invalid limit parameter", err)
                        c.JSON(http.StatusBadRequest, gin.H{"error": "limit must be a positive integer"})
                        return
                }</span>
                <span class="cov0" title="0">limit = v</span>
        }

        <span class="cov8" title="1">offset := 0
        if s := c.Query("offset"); s != "" </span><span class="cov0" title="0">{
                v, err := strconv.Atoi(s)
                if err != nil || v &lt; 0 </span><span class="cov0" title="0">{
                        h.log.ErrorErr("invalid offset parameter", err)
                        c.JSON(http.StatusBadRequest, gin.H{"error": "offset must be a non-negative integer"})
                        return
                }</span>
                <span class="cov0" title="0">offset = v</span>
        }

        <span class="cov8" title="1">var total int
        q := c.Query("query")
        var previews []models.CoursePreview
        var err error
        if q != "" </span><span class="cov8" title="1">{
                previews, total, err = h.CourseService.SearchCoursesPreview(ctx, q, limit, offset)
        }</span> else<span class="cov8" title="1"> {
                previews, total, err = h.CourseService.CoursesPreview(ctx, limit, offset)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                h.log.ErrorErr("ListCourses failed", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "could not fetch courses"})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "total":   total,
                "courses": previews,
        })</span>
}

type newCourseRequest struct {
        Title       string `json:"title" binding:"required"`
        Description string `json:"description" binding:"required"`
}

func (h *CourseHandler) CreateCourse(c *gin.Context) <span class="cov8" title="1">{
        var input newCourseRequest
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">authorID, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov8" title="1">course := models.Course{
                Title:       input.Title,
                Description: input.Description,
                AuthorID:    authorID.(uuid.UUID),
                Status:      models.StatusHidden,
        }
        id, err := h.CourseService.CreateCourse(c.Request.Context(), course)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"id": id})</span>
}

func (h *CourseHandler) PublishCourse(c *gin.Context) <span class="cov0" title="0">{
        id, ok := c.Params.Get("course_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "course_id is required"})
                return
        }</span>
        <span class="cov0" title="0">courseID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">userID, ex := c.Get(ClientIDCtx)
        if !ex </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">userUUID := userID.(uuid.UUID)
        err = h.CourseService.Publish(c.Request.Context(), courseID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{})</span>
}

func (h *CourseHandler) HideCourse(c *gin.Context) <span class="cov0" title="0">{
        id, ok := c.Params.Get("course_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "course_id is required"})
                return
        }</span>
        <span class="cov0" title="0">courseID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">userID, ex := c.Get(ClientIDCtx)
        if !ex </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">userUUID := userID.(uuid.UUID)
        err = h.CourseService.Hide(c.Request.Context(), courseID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{})</span>
}

func (h *CourseHandler) SubscribeCourse(c *gin.Context) <span class="cov0" title="0">{
        courseIDStr := c.Param("course_id")
        courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov0" title="0">id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">userID := id.(uuid.UUID)

        err = h.CourseService.Subscribe(c.Request.Context(), courseID, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == app_errors.ErrAlreadySubscribed </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": "subscribed"})</span>
}

func (h *CourseHandler) GetSubscribedCourses(c *gin.Context) <span class="cov0" title="0">{
        id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">userID := id.(uuid.UUID)

        previews, err := h.CourseService.GetSubscribedCourses(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"courses": previews})</span>
}

func (h *CourseHandler) GetMyCourses(c *gin.Context) <span class="cov0" title="0">{
        id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">authorID := id.(uuid.UUID)

        previews, err := h.CourseService.GetMyCourses(c.Request.Context(), authorID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"courses": previews})</span>
}

func (h *CourseHandler) GetCourseStatus(c *gin.Context) <span class="cov0" title="0">{
        courseIDStr := c.Param("course_id")
        courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov0" title="0">status, err := h.CourseService.GetCourseStatus(c.Request.Context(), courseID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "course_id": courseID.String(),
                "status":    status,
        })</span>
}

func (h *CourseHandler) RateCourse(c *gin.Context) <span class="cov8" title="1">{
        courseIDStr := c.Param("course_id")
        courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>
        <span class="cov8" title="1">id, exists := c.Get(ClientIDCtx)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov8" title="1">userID := id.(uuid.UUID)

        if err := h.CourseService.RateCourse(c.Request.Context(), courseID, userID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": "rated"})</span>
}

func (h *CourseHandler) UnrateCourse(c *gin.Context) <span class="cov0" title="0">{
        courseIDStr := c.Param("course_id")
        courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>
        <span class="cov0" title="0">id, exists := c.Get(ClientIDCtx)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">userID := id.(uuid.UUID)

        if err := h.CourseService.UnrateCourse(c.Request.Context(), courseID, userID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": "unrated"})</span>
}

func (h *CourseHandler) GetRatingStatus(c *gin.Context) <span class="cov0" title="0">{
        id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">userID := id.(uuid.UUID)

        statusMap, err := h.CourseService.GetRatingStatus(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"rated_status": statusMap})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controllers

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "SkillForge/pkg/logger"
        "context"
        "errors"
        "io"
        "mime"
        "net/http"
        "path/filepath"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type LessonService interface {
        CreateLesson(ctx context.Context, lesson models.Lesson, authorID uuid.UUID) (*models.Lesson, error)
        CreateModule(ctx context.Context, module models.Module, authorID uuid.UUID) (*models.Module, error)
        CourseContent(ctx context.Context, courseID uuid.UUID) ([]models.Contents, error)
        DeleteLesson(ctx context.Context, courseID, lessonID, moduleID uuid.UUID, authorID uuid.UUID) error
        DeleteModule(ctx context.Context, courseID, moduleID uuid.UUID, authorID uuid.UUID) error
        SwapLessons(ctx context.Context, lessonID1, lessonID2, authorID uuid.UUID) error
        SwapModules(ctx context.Context, moduleID1, moduleID2, courseID, authorID uuid.UUID) error
        CreateContent(ctx context.Context, content models.CourseContent, authorID uuid.UUID) (*models.CourseContent, error)
        CreateMediaContent(ctx context.Context, lessonID uuid.UUID, mediaType, filename string, file io.Reader, size int64, contentType string, authorID uuid.UUID) (*models.CourseContent, error)
        GetLessonDetail(ctx context.Context, lessonID uuid.UUID) (models.LessonDetail, error)
}

type LessonHandler struct {
        LessonService LessonService
        log           logger.Log
}

func NewLessonHandler(l logger.Log, lessonService LessonService) *LessonHandler <span class="cov8" title="1">{
        return &amp;LessonHandler{
                LessonService: lessonService,
                log:           l,
        }
}</span>

func (h *LessonHandler) GetLessonDetail(c *gin.Context) <span class="cov8" title="1">{
        lessonIDStr := c.Param("lesson_id")
        lessonID, err := uuid.Parse(lessonIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid lesson_id"})
                return
        }</span>

        <span class="cov8" title="1">detail, err := h.LessonService.GetLessonDetail(c.Request.Context(), lessonID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, detail)</span>
}

func (h *LessonHandler) CreateMediaContent(c *gin.Context) <span class="cov8" title="1">{
        lessonIDStr := c.PostForm("lesson_id")
        lessonID, err := uuid.Parse(lessonIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid lesson_id"})
                return
        }</span>
        <span class="cov8" title="1">mediaType := c.PostForm("type")
        if mediaType != models.ContentTypeImage &amp;&amp; mediaType != models.ContentTypeVideo </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "type must be either 'image' or 'video'"})
                return
        }</span>

        <span class="cov8" title="1">fileHeader, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "file is required"})
                return
        }</span>
        <span class="cov8" title="1">file, err := fileHeader.Open()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "cannot open file"})
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        ct := fileHeader.Header.Get("CourseContent-Type")
        if ct == "" </span><span class="cov8" title="1">{
                ct = mime.TypeByExtension(filepath.Ext(fileHeader.Filename))
                if ct == "" </span><span class="cov0" title="0">{
                        ct = "application/octet-stream"
                }</span>
        }

        <span class="cov8" title="1">id, exists := c.Get(ClientIDCtx)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov8" title="1">authorID := id.(uuid.UUID)

        content, err := h.LessonService.CreateMediaContent(c.Request.Context(), lessonID, mediaType, fileHeader.Filename, file, fileHeader.Size, ct, authorID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, app_errors.ErrNotCourseAuthor) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov8" title="1">c.JSON(http.StatusCreated, content)</span>
}

type createLessonRequest struct {
        ModuleID    uuid.UUID `json:"module_id" binding:"required"`
        LessonTitle string    `json:"lesson_title" binding:"required"`
}

func (h *LessonHandler) SwapLessons(c *gin.Context) <span class="cov8" title="1">{
        courseIDStr := c.Param("course_id")
        _, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov8" title="1">lessonID1Str := c.Query("lesson_id_1")
        lessonID2Str := c.Query("lesson_id_2")
        if lessonID1Str == "" || lessonID2Str == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "lesson_id_1 and lesson_id_2 required"})
                return
        }</span>
        <span class="cov8" title="1">lessonID1, err := uuid.Parse(lessonID1Str)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid lesson_id_1"})
                return
        }</span>
        <span class="cov8" title="1">lessonID2, err := uuid.Parse(lessonID2Str)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid lesson_id_2"})
                return
        }</span>

        <span class="cov8" title="1">id, exists := c.Get(ClientIDCtx)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov8" title="1">authorID := id.(uuid.UUID)

        if err := h.LessonService.SwapLessons(c.Request.Context(), lessonID1, lessonID2, authorID); err != nil </span><span class="cov0" title="0">{
                h.log.ErrorErr("err", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": "lessons swapped"})</span>
}

func (h *LessonHandler) SwapModules(c *gin.Context) <span class="cov0" title="0">{
        courseIDStr := c.Param("course_id")
        courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov0" title="0">moduleID1Str := c.Query("module_id_1")
        moduleID2Str := c.Query("module_id_2")
        if moduleID1Str == "" || moduleID2Str == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "module_id_1 and module_id_2 required"})
                return
        }</span>
        <span class="cov0" title="0">moduleID1, err := uuid.Parse(moduleID1Str)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid module_id_1"})
                return
        }</span>
        <span class="cov0" title="0">moduleID2, err := uuid.Parse(moduleID2Str)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid module_id_2"})
                return
        }</span>

        <span class="cov0" title="0">id, exists := c.Get(ClientIDCtx)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">authorID := id.(uuid.UUID)

        if err := h.LessonService.SwapModules(c.Request.Context(), moduleID1, moduleID2, courseID, authorID); err != nil </span><span class="cov0" title="0">{
                h.log.ErrorErr("err", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": "modules swapped"})</span>
}

func (h *LessonHandler) CreateLesson(c *gin.Context) <span class="cov8" title="1">{
        var input createLessonRequest
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">courseIDStr, ok := c.Params.Get("course_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "course_id is required"})
                return
        }</span>
        <span class="cov8" title="1">courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov8" title="1">id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov8" title="1">authorID := id.(uuid.UUID)

        lesson := models.Lesson{
                CourseID:    courseID,
                ModuleID:    input.ModuleID,
                LessonTitle: input.LessonTitle,
        }
        createdLesson, err := h.LessonService.CreateLesson(c.Request.Context(), lesson, authorID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, app_errors.ErrDuplicateLesson) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov8" title="1">c.JSON(http.StatusCreated, createdLesson)</span>
}

type createModuleRequest struct {
        Title string `json:"title" binding:"required"`
}

func (h *LessonHandler) CreateModule(c *gin.Context) <span class="cov8" title="1">{
        var req createModuleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">courseIDStr, ok := c.Params.Get("course_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "course_id is required"})
                return
        }</span>
        <span class="cov8" title="1">courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov8" title="1">id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov8" title="1">authorID := id.(uuid.UUID)

        module := models.Module{
                CourseID: courseID,
                Title:    req.Title,
        }
        createdModule, err := h.LessonService.CreateModule(c.Request.Context(), module, authorID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, app_errors.ErrDuplicateModule) </span><span class="cov8" title="1">{
                        c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }
        <span class="cov8" title="1">c.JSON(http.StatusCreated, createdModule)</span>
}

func (h *LessonHandler) CourseContent(c *gin.Context) <span class="cov0" title="0">{
        courseIDStr, ok := c.Params.Get("course_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "course_id is required"})
                return
        }</span>
        <span class="cov0" title="0">courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">content, err := h.LessonService.CourseContent(c.Request.Context(), courseID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, content)</span>
}

func (h *LessonHandler) DeleteLesson(c *gin.Context) <span class="cov0" title="0">{
        courseIDStr, ok := c.Params.Get("course_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "course_id is required"})
                return
        }</span>
        <span class="cov0" title="0">courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov0" title="0">moduleIDStr, ok := c.Params.Get("module_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "module_id is required"})
                return
        }</span>
        <span class="cov0" title="0">moduleID, err := uuid.Parse(moduleIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid module_id"})
                return
        }</span>

        <span class="cov0" title="0">lessonIDStr, ok := c.Params.Get("lesson_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "lesson_id is required"})
                return
        }</span>
        <span class="cov0" title="0">lessonID, err := uuid.Parse(lessonIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid lesson_id"})
                return
        }</span>

        <span class="cov0" title="0">id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">authorID := id.(uuid.UUID)

        if err := h.LessonService.DeleteLesson(c.Request.Context(), courseID, lessonID, moduleID, authorID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": "lesson deleted"})</span>
}

func (h *LessonHandler) DeleteModule(c *gin.Context) <span class="cov8" title="1">{
        courseIDStr, ok := c.Params.Get("course_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "course_id is required"})
                return
        }</span>
        <span class="cov8" title="1">courseID, err := uuid.Parse(courseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid course_id"})
                return
        }</span>

        <span class="cov8" title="1">moduleIDStr, ok := c.Params.Get("module_id")
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "module_id is required"})
                return
        }</span>
        <span class="cov8" title="1">moduleID, err := uuid.Parse(moduleIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid module_id"})
                return
        }</span>

        <span class="cov8" title="1">id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov8" title="1">authorID := id.(uuid.UUID)

        if err := h.LessonService.DeleteModule(c.Request.Context(), courseID, moduleID, authorID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": "module deleted"})</span>
}

type createContentRequest struct {
        LessonID uuid.UUID `json:"lesson_id" binding:"required"`
        Type     string    `json:"type" binding:"required"` // "text", "image", "video", "quiz"
        Text     *string   `json:"text,omitempty"`
        QuizJSON *string   `json:"quiz_json,omitempty"`
}

func (h *LessonHandler) CreateContent(c *gin.Context) <span class="cov0" title="0">{
        var req createContentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">id, ok := c.Get(ClientIDCtx)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">authorID := id.(uuid.UUID)
        content := models.CourseContent{
                LessonID: req.LessonID,
                Type:     req.Type,
                Text:     req.Text,
                QuizJSON: req.QuizJSON,
        }

        createdContent, err := h.LessonService.CreateContent(c.Request.Context(), content, authorID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                h.log.ErrorErr("err", err)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, createdContent)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controllers

import (
        "SkillForge/internal/app_errors"
        "SkillForge/pkg/logger"
        _ "encoding/json"
        "errors"
        "fmt"
        "github.com/gin-gonic/gin"
        "net/http"
        "strings"
        "time"
)

const (
        ClientIDCtx    = "client_id"
        ClientRolesCtx = "client_roles"
)

func RequireRoles(allowedRoles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        roleSet := make(map[string]struct{}, len(allowedRoles))
        for _, r := range allowedRoles </span><span class="cov0" title="0">{
                roleSet[r] = struct{}{}
        }</span>
        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{
                raw, exists := c.Get(ClientRolesCtx)
                if !exists </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "roles not found"})
                        return
                }</span>

                <span class="cov0" title="0">roles, ok := raw.([]string)
                if !ok </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "invalid roles format"})
                        return
                }</span>

                <span class="cov0" title="0">for _, role := range roles </span><span class="cov0" title="0">{
                        if _, allowed := roleSet[role]; allowed </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>
                }
                <span class="cov0" title="0">c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "insufficient permissions"})</span>
        }
}

func (h *AuthHandler) AuthMiddleware(c *gin.Context) <span class="cov8" title="1">{
        authHeader := c.GetHeader("Authorization")
        var token string
        if parts := strings.Split(authHeader, "Bearer "); len(parts) == 2 </span><span class="cov8" title="1">{
                token = parts[1]
        }</span>
        <span class="cov8" title="1">if token == "" </span><span class="cov8" title="1">{
                c.AbortWithStatus(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">parsedToken, err := h.AuthService.ParseToken(c.Request.Context(), token)
        if err != nil </span><span class="cov8" title="1">{
                h.log.Info("failed to parse token", err)
                if errors.Is(err, app_errors.ErrTokenExpired) </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": app_errors.ErrTokenExpired.Error()})
                        return
                }</span>
                <span class="cov8" title="1">c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "cant parse token"})
                return</span>
        }
        <span class="cov8" title="1">if !h.AuthService.IsAccessToken(c.Request.Context(), parsedToken) </span><span class="cov0" title="0">{
                //h.log.Error("not access")\
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "not access token"})

                return
        }</span>

        <span class="cov8" title="1">userID, roles, err := h.AuthService.AccessClaims(c.Request.Context(), token)
        if err != nil </span><span class="cov0" title="0">{
                //h.log.Error("claims")
                c.AbortWithStatus(http.StatusUnauthorized)
                return
        }</span>
        <span class="cov8" title="1">user, err := h.AuthService.User(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.AbortWithStatus(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">c.Set(ClientIDCtx, user.ID)
        c.Set(ClientRolesCtx, roles)
        c.Next()</span>
}

func LoggingMiddleware(logger logger.Log) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                c.Next()

                latency := time.Since(start)
                clientIP := c.ClientIP()
                method := c.Request.Method
                path := c.Request.URL.Path
                rawQuery := c.Request.URL.RawQuery
                if rawQuery != "" </span><span class="cov0" title="0">{
                        path = fmt.Sprintf("%s?%s", path, rawQuery)
                }</span>
                <span class="cov0" title="0">status := c.Writer.Status()

                msg := fmt.Sprintf("%s %s", method, path)

                logger.Info(msg,
                        "status", status,
                        "latency", latency,
                        "client_ip", clientIP,
                )

                for _, ginErr := range c.Errors </span><span class="cov0" title="0">{

                        logger.ErrorErr("HTTP request error", ginErr.Err,
                                "status", status,
                                "method", method,
                                "path", path,
                        )
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controllers

import (
        "github.com/gin-gonic/gin"
        "net/http"
)

type StatusHandler struct {
}

func NewStatusHandler() *StatusHandler <span class="cov0" title="0">{
        return &amp;StatusHandler{}
}</span>

func (h *StatusHandler) Status(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"status": "Available"})
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package http

import (
        "SkillForge/internal/delivery/http/controllers"
        "SkillForge/internal/models"
        "SkillForge/internal/service"
        "SkillForge/pkg/logger"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

func InitRoutes(l logger.Log, u service.Collection) *gin.Engine <span class="cov0" title="0">{
        r := gin.New()
        r.Use(gin.Recovery())

        config := cors.Config{
                AllowOrigins:     []string{"http://localhost:5173"},
                AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "CourseContent-Type", "Accept", "Authorization"},
                ExposeHeaders:    []string{"CourseContent-Length"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        }

        r.Use(cors.New(config))

        statusController := controllers.NewStatusHandler()
        authController := controllers.NewAuthHandler(l, u.AuthService)
        courseController := controllers.NewCourseHandler(l, u.CourseService)
        lessonController := controllers.NewLessonHandler(l, u.LessonService)

        v1 := r.Group("/v1", controllers.LoggingMiddleware(l))
        </span><span class="cov0" title="0">{
                v1.GET("/status", statusController.Status)

                v1.GET("/me", authController.AuthMiddleware, authController.Me)

                auth := v1.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.POST("/login", authController.Login)
                        auth.POST("/register", authController.Register)
                        auth.POST("/refresh", authController.Refresh)
                }</span>

                <span class="cov0" title="0">courses := v1.Group("/courses")
                </span><span class="cov0" title="0">{
                        courses.GET("", courseController.ListCoursePreview)
                        courses.GET("/:course_id/preview", courseController.CourseByID)
                        courses.GET("/:course_id/content", lessonController.CourseContent)
                        courses.GET("/:course_id/status", courseController.GetCourseStatus)

                        author := courses.Group("", authController.AuthMiddleware, controllers.RequireRoles(models.AuthorRole))
                        </span><span class="cov0" title="0">{
                                author.PUT("/:course_id/logo", courseController.UploadCourseLogo)
                                author.POST("", courseController.CreateCourse)
                                author.PATCH("/:course_id/publish", courseController.PublishCourse)
                                author.PATCH("/:course_id/hide", courseController.HideCourse)
                                author.POST("/:course_id/create-lesson", lessonController.CreateLesson)
                                author.POST("/:course_id/create-module", lessonController.CreateModule)
                                author.DELETE("/:course_id/module/:module_id/lesson/:lesson_id", lessonController.DeleteLesson)
                                author.DELETE("/:course_id/module/:module_id", lessonController.DeleteModule)
                                author.GET("/my-courses", courseController.GetMyCourses)
                                author.PATCH("/:course_id/lessons/swap", lessonController.SwapLessons)
                                author.PATCH("/:course_id/modules/swap", lessonController.SwapModules)
                                author.POST("/:course_id/lesson/content", lessonController.CreateContent)
                                author.POST("/:course_id/lesson/content/media", lessonController.CreateMediaContent)
                                author.GET("/:course_id/lessons/:lesson_id", lessonController.GetLessonDetail)
                        }</span>

                        <span class="cov0" title="0">client := courses.Group("", authController.AuthMiddleware, controllers.RequireRoles(models.ClientRole))
                        </span><span class="cov0" title="0">{
                                client.POST("/:course_id/subscribe", courseController.SubscribeCourse)
                                client.GET("/subscriptions", courseController.GetSubscribedCourses)
                                client.GET("/lessons/:lesson_id", lessonController.GetLessonDetail)
                                client.POST("/:course_id/star", courseController.RateCourse)
                                client.DELETE("/:course_id/star", courseController.UnrateCourse)
                                client.GET("/rated-status", courseController.GetRatingStatus)
                        }</span>

                }

        }
        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package auth

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "SkillForge/pkg/logger"
        "context"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
        "time"
)

type AuthRepo interface {
        CreateUser(ctx context.Context, user models.User) (*models.User, error)
        UserByName(ctx context.Context, username string) (*models.User, error)
        UserByID(ctx context.Context, id uuid.UUID) (*models.User, error)
}

type tokenRepo interface {
        Create(ctx context.Context, userID uuid.UUID, token *jwt.Token) (*models.RefreshToken, error)
        ByPrimaryKey(ctx context.Context, userID uuid.UUID, token *jwt.Token) (*models.RefreshToken, error)
        DeleteUserTokens(ctx context.Context, userID uuid.UUID) error
}

type AuthService struct {
        log        logger.Log
        jwtManager *JWTManager
        authRepo   AuthRepo
        tokenRepo  tokenRepo
}

func NewAuthService(l logger.Log, manager *JWTManager, aRepo AuthRepo, tRepo tokenRepo) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                log:        l,
                jwtManager: manager,
                authRepo:   aRepo,
                tokenRepo:  tRepo,
        }
}</span>

func (u *AuthService) RefreshTokens(ctx context.Context, token string) (*models.TokenPair, error) <span class="cov8" title="1">{
        curToken, err := u.jwtManager.Parse(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">userIdStr, err := curToken.Claims.GetSubject()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">userID, err := uuid.Parse(userIdStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tokenRecord, err := u.tokenRepo.ByPrimaryKey(ctx, userID, curToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">user, err := u.authRepo.UserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if tokenRecord.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, app_errors.ErrTokenExpired
        }</span>
        <span class="cov8" title="1">tokenPair, err := u.jwtManager.GenerateTokenPair(user.ID, user.Roles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := u.tokenRepo.DeleteUserTokens(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if _, err := u.tokenRepo.Create(ctx, user.ID, tokenPair.RefreshToken); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return tokenPair, nil</span>

}

func (u *AuthService) ParseToken(ctx context.Context, token string) (*jwt.Token, error) <span class="cov8" title="1">{
        return u.jwtManager.Parse(token)
}</span>

func (u *AuthService) IsAccessToken(ctx context.Context, token *jwt.Token) bool <span class="cov8" title="1">{
        return u.jwtManager.TokenType(token, AccessTokenType)
}</span>

func (u *AuthService) AccessClaims(ctx context.Context, token string) (userID uuid.UUID, roles []string, err error) <span class="cov8" title="1">{
        claims, err := u.jwtManager.AccessClaims(token)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, nil, err
        }</span>
        <span class="cov8" title="1">roles = claims.Roles
        userID = claims.UserID
        err = nil
        return</span>
}

func (u *AuthService) User(ctx context.Context, id uuid.UUID) (*models.User, error) <span class="cov8" title="1">{
        user, err := u.authRepo.UserByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

func (u *AuthService) LoginUser(ctx context.Context, username, password string) (accessToken, refreshToken string, err error) <span class="cov8" title="1">{
        user, err := u.authRepo.UserByName(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">if !checkPasswordHash(password, user.Password) </span><span class="cov8" title="1">{
                return "", "", app_errors.ErrIncorrectPassword
        }</span>

        <span class="cov8" title="1">tokenPair, err := u.jwtManager.GenerateTokenPair(user.ID, user.Roles)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">err = u.tokenRepo.DeleteUserTokens(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">_, err = u.tokenRepo.Create(ctx, user.ID, tokenPair.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return tokenPair.AccessToken.Raw, tokenPair.RefreshToken.Raw, nil</span>
}

func (u *AuthService) CreateUser(ctx context.Context, user models.User) (*models.User, error) <span class="cov8" title="1">{
        var err error

        if len(user.Password) &gt; 16 || len(user.Password) &lt; 6 </span><span class="cov8" title="1">{
                return nil, app_errors.ErrIncorrectPassword
        }</span>

        <span class="cov8" title="1">user.Password, err = hashPassword(user.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">createdUser, err := u.authRepo.CreateUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return createdUser, nil</span>
}

func hashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

func checkPasswordHash(password, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package auth

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "errors"
        "fmt"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "time"
)

const (
        AccessTokenType  = "access"
        RefreshTokenType = "refresh"
)

var signingMethod = jwt.SigningMethodHS256

type JWTManager struct {
        secretKey  string
        accessTTL  time.Duration
        refreshTTL time.Duration
        issuer     string
}

func NewJWTManager(secretKey, issuer string, accessTTL, refreshTTL time.Duration) *JWTManager <span class="cov8" title="1">{
        return &amp;JWTManager{
                secretKey:  secretKey,
                accessTTL:  accessTTL,
                refreshTTL: refreshTTL,
                issuer:     issuer,
        }
}</span>

type AccessTokenClaims struct {
        TokenType string    `json:"token_type"`
        UserID    uuid.UUID `json:"user_id"`
        Roles     []string  `json:"roles"`
        jwt.RegisteredClaims
}

type RefreshTokenClaims struct {
        TokenType string    `json:"token_type"`
        UserID    uuid.UUID `json:"user_id"`
        jwt.RegisteredClaims
}

func (j *JWTManager) AccessClaims(tokenStr string) (*AccessTokenClaims, error) <span class="cov8" title="1">{
        claims := &amp;AccessTokenClaims{}
        _, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if token.Method != signingMethod </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(j.secretKey), nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse access token: %w", err)
        }</span>

        <span class="cov8" title="1">if claims.TokenType != AccessTokenType </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong token type: expected %q, got %q", AccessTokenType, claims.TokenType)
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

func (j *JWTManager) Parse(token string) (*jwt.Token, error) <span class="cov8" title="1">{
        parser := jwt.Parser{}
        jwtToken, err := parser.Parse(token, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if token.Method != signingMethod </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(j.secretKey), nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov0" title="0">{
                        return nil, app_errors.ErrTokenExpired
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to parse access token: %w", err)</span>
        }
        <span class="cov8" title="1">return jwtToken, nil</span>
}

func (j *JWTManager) TokenType(token *jwt.Token, t string) bool <span class="cov8" title="1">{
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                fmt.Println(1)
                return false
        }</span>
        <span class="cov8" title="1">if tokenType, ok := claims["token_type"].(string); ok </span><span class="cov8" title="1">{
                return tokenType == t
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (j *JWTManager) GenerateTokenPair(userID uuid.UUID, roles []string) (*models.TokenPair, error) <span class="cov8" title="1">{
        now := time.Now()
        accessToken := jwt.NewWithClaims(signingMethod, AccessTokenClaims{
                TokenType: AccessTokenType,
                RegisteredClaims: jwt.RegisteredClaims{
                        Subject:   userID.String(),
                        Issuer:    j.issuer,
                        ExpiresAt: jwt.NewNumericDate(now.Add(j.accessTTL)),
                        IssuedAt:  jwt.NewNumericDate(now),
                },
                UserID: userID,
                Roles:  roles,
        })

        accessKey := []byte(j.secretKey)
        signedAccessToken, err := accessToken.SignedString(accessKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access token signing failed: %v", err)
        }</span>
        <span class="cov8" title="1">accessToken, err = j.Parse(signedAccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access token parsinh failed: %v", err)
        }</span>

        <span class="cov8" title="1">refreshToken := jwt.NewWithClaims(signingMethod, RefreshTokenClaims{
                TokenType: RefreshTokenType,
                RegisteredClaims: jwt.RegisteredClaims{
                        Subject:   userID.String(),
                        Issuer:    j.issuer,
                        ExpiresAt: jwt.NewNumericDate(now.Add(j.refreshTTL)),
                        IssuedAt:  jwt.NewNumericDate(now),
                },
                UserID: userID,
        })

        key := []byte(j.secretKey)
        signedRefreshToken, err := refreshToken.SignedString(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("refresh token signing failed: %v", err)
        }</span>
        <span class="cov8" title="1">refreshToken, err = j.Parse(signedRefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("refresh token parsinh failed: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;models.TokenPair{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package course

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "SkillForge/pkg/logger"
        "context"
        "fmt"
        "io"
        "mime"
        "path/filepath"
        "strings"

        "github.com/google/uuid"
)

const (
        maxLogoSizeBytes = 2 &lt;&lt; 40
)

type userRepo interface {
        UserByID(ctx context.Context, id uuid.UUID) (*models.User, error)
}
type courseRepo interface {
        NewCourse(ctx context.Context, course *models.Course) (uuid.UUID, error)
        CourseByID(ctx context.Context, id uuid.UUID) (*models.Course, error)
        ChangeStatus(ctx context.Context, id uuid.UUID, status string) error
        UpdateCourseLogo(ctx context.Context, courseID uuid.UUID, logoObjectKey string) error
        ListPublicCourses(ctx context.Context, limit int, offset int) ([]models.Course, error)
        CountPublicCourses(ctx context.Context) (int, error)
        ListCoursesByAuthor(ctx context.Context, authorID uuid.UUID) ([]models.Course, error)
        IncrementStars(ctx context.Context, courseID uuid.UUID) error
        DecrementStars(ctx context.Context, courseID uuid.UUID) error
}

type searchRepo interface {
        Index(ctx context.Context, course models.Course) error
        Search(ctx context.Context, query string, size int) ([]uuid.UUID, error)
        Delete(ctx context.Context, id uuid.UUID) error
        Count(ctx context.Context, query string) (int, error)
}

type logoRepo interface {
        GetLogoURL(ctx context.Context, objectKey string) (string, error)
        UploadLogo(ctx context.Context, courseID uuid.UUID, filename string, reader io.Reader, size int64, contentType string) (objectKey string, err error)
        DeleteLogo(ctx context.Context, objectKey string) error
}

type lessonRepo interface {
        LessonsByCourse(ctx context.Context, courseID uuid.UUID) ([]models.Lesson, error)
}

type subscriptionRepo interface {
        SubscribeCourse(ctx context.Context, courseID, userID uuid.UUID) error
        GetSubscribedCourses(ctx context.Context, userID uuid.UUID) ([]models.Course, error)
}
type ratingRepo interface {
        RemoveRating(ctx context.Context, courseID, userID uuid.UUID) error
        AddRating(ctx context.Context, courseID, userID uuid.UUID) error
        IsRated(ctx context.Context, courseID, userID uuid.UUID) (bool, error)
}

type CourseService struct {
        log          logger.Log
        courseRepo   courseRepo
        searchRepo   searchRepo
        logoRepo     logoRepo
        lessonRepo   lessonRepo
        userRepo     userRepo
        subscription subscriptionRepo
        ratingRepo   ratingRepo
}

func NewCourseService(log logger.Log, courseRepo courseRepo, searchRepo searchRepo,
        logoRepo logoRepo, lessonRepo lessonRepo,
        useRepo userRepo, subRepo subscriptionRepo,
        ratingRepo ratingRepo,

) *CourseService <span class="cov8" title="1">{
        return &amp;CourseService{
                log:          log,
                courseRepo:   courseRepo,
                searchRepo:   searchRepo,
                logoRepo:     logoRepo,
                lessonRepo:   lessonRepo,
                userRepo:     useRepo,
                subscription: subRepo,
                ratingRepo:   ratingRepo,
        }
}</span>

func (s *CourseService) RateCourse(ctx context.Context, courseID, userID uuid.UUID) error <span class="cov8" title="1">{
        courses, err := s.subscription.GetSubscribedCourses(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var ok bool
        for _, c := range courses </span><span class="cov8" title="1">{
                if c.ID == courseID </span><span class="cov8" title="1">{
                        ok = true
                }</span>
        }
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("course %s not found in subscription", courseID)
        }</span>
        <span class="cov8" title="1">if err := s.ratingRepo.AddRating(ctx, courseID, userID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return s.courseRepo.IncrementStars(ctx, courseID)</span>
}

func (s *CourseService) UnrateCourse(ctx context.Context, courseID, userID uuid.UUID) error <span class="cov8" title="1">{
        courses, err := s.subscription.GetSubscribedCourses(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var ok bool
        for _, c := range courses </span><span class="cov8" title="1">{
                if c.ID == courseID </span><span class="cov8" title="1">{
                        ok = true
                }</span>
        }
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("course %s not found in subscription", courseID)
        }</span>
        <span class="cov8" title="1">if err := s.ratingRepo.RemoveRating(ctx, courseID, userID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return s.courseRepo.DecrementStars(ctx, courseID)</span>
}

func (s *CourseService) CourseByID(ctx context.Context, id uuid.UUID) (*models.CoursePreview, error) <span class="cov8" title="1">{
        course, err := s.courseRepo.CourseByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var logoURL string
        if course.LogoObjectKey != "" </span><span class="cov8" title="1">{
                logoURL, err = s.logoRepo.GetLogoURL(ctx, course.LogoObjectKey)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.ErrorErr("CourseByID: failed to get logo URL", err)
                }</span>
        }

        <span class="cov8" title="1">author, err := s.userRepo.UserByID(ctx, course.AuthorID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.ErrorErr("CourseByID: failed to get author", err)
                author = &amp;models.User{Username: ""}
        }</span>

        <span class="cov8" title="1">preview := models.CoursePreview{
                ID:          course.ID,
                Title:       course.Title,
                Description: course.Description,
                AuthorName:  author.Username,
                LogoURL:     logoURL,
                StarsCount:  course.StarsCount,
        }

        return &amp;preview, nil</span>
}

func (s *CourseService) CoursesPreview(ctx context.Context, count int, offset int) ([]models.CoursePreview, int, error) <span class="cov8" title="1">{
        courses, err := s.courseRepo.ListPublicCourses(ctx, count, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">total, err := s.courseRepo.CountPublicCourses(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">previews := make([]models.CoursePreview, 0, len(courses))
        for _, c := range courses </span><span class="cov8" title="1">{
                desc := c.Description
                if len(desc) &gt; 200 </span><span class="cov0" title="0">{
                        desc = desc[:200] + ""
                }</span>

                <span class="cov8" title="1">logoURL := ""
                if c.LogoObjectKey != "" </span><span class="cov8" title="1">{
                        u, err := s.logoRepo.GetLogoURL(ctx, c.LogoObjectKey)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.ErrorErr("preview: failed to get logo URL", err)
                        }</span> else<span class="cov8" title="1"> {
                                logoURL = u
                        }</span>
                }

                <span class="cov8" title="1">author, err := s.userRepo.UserByID(ctx, c.AuthorID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.ErrorErr("search preview: failed to get author by id", err)
                }</span>

                <span class="cov8" title="1">previews = append(previews, models.CoursePreview{
                        ID:          c.ID,
                        Title:       c.Title,
                        AuthorName:  author.Username,
                        Description: c.Description,
                        LogoURL:     logoURL,
                        StarsCount:  c.StarsCount,
                })</span>
        }

        <span class="cov8" title="1">return previews, total, nil</span>
}

func (s *CourseService) SearchCoursesPreview(ctx context.Context, query string, count int, offset int) ([]models.CoursePreview, int, error) <span class="cov0" title="0">{
        ids, err := s.searchRepo.Search(ctx, query, count+offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("search preview: elastic search failed: %w", err)
        }</span>

        <span class="cov0" title="0">ids = ids[offset:]
        if len(ids) &gt; count </span><span class="cov0" title="0">{
                ids = ids[:count]
        }</span>

        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return []models.CoursePreview{}, 0, nil
        }</span>

        <span class="cov0" title="0">total, err := s.searchRepo.Count(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("search count failed: %w", err)
        }</span>

        <span class="cov0" title="0">previews := make([]models.CoursePreview, 0, len(ids))
        for _, id := range ids </span><span class="cov0" title="0">{
                course, err := s.courseRepo.CourseByID(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.ErrorErr("search preview: failed to load course by id", err)
                        continue</span>
                }

                <span class="cov0" title="0">desc := course.Description
                if len(desc) &gt; 200 </span><span class="cov0" title="0">{
                        desc = desc[:200] + ""
                }</span>

                <span class="cov0" title="0">logoURL := ""
                if course.LogoObjectKey != "" </span><span class="cov0" title="0">{
                        u, err := s.logoRepo.GetLogoURL(ctx, course.LogoObjectKey)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.ErrorErr("search preview: failed to get logo URL", err)
                        }</span> else<span class="cov0" title="0"> {
                                logoURL = u
                        }</span>
                }

                <span class="cov0" title="0">author, err := s.userRepo.UserByID(ctx, course.AuthorID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.ErrorErr("search preview: failed to get author by id", err)
                }</span>
                <span class="cov0" title="0">previews = append(previews, models.CoursePreview{
                        ID:          course.ID,
                        Title:       course.Title,
                        Description: course.Description,
                        LogoURL:     logoURL,
                        AuthorName:  author.Username,
                        StarsCount:  course.StarsCount,
                })</span>
        }

        <span class="cov0" title="0">return previews, total, nil</span>
}

func (s *CourseService) CreateCourse(ctx context.Context, course models.Course) (uuid.UUID, error) <span class="cov0" title="0">{
        id, err := s.courseRepo.NewCourse(ctx, &amp;course)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

func (s *CourseService) Publish(ctx context.Context, id uuid.UUID, authorID uuid.UUID) error <span class="cov8" title="1">{
        course, err := s.courseRepo.CourseByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if authorID != course.AuthorID </span><span class="cov0" title="0">{
                return app_errors.ErrNotCourseAuthor
        }</span>
        <span class="cov8" title="1">err = s.courseRepo.ChangeStatus(ctx, id, models.StatusPublic)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.searchRepo.Index(ctx, *course)
        if err != nil </span><span class="cov0" title="0">{
                s.log.ErrorErr("error indexing course", err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *CourseService) Hide(ctx context.Context, id uuid.UUID, authorID uuid.UUID) error <span class="cov8" title="1">{
        course, err := s.courseRepo.CourseByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if authorID != course.AuthorID </span><span class="cov0" title="0">{
                return app_errors.ErrNotCourseAuthor
        }</span>
        <span class="cov8" title="1">if err := s.courseRepo.ChangeStatus(ctx, id, models.StatusHidden); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *CourseService) UploadCourseLogo(
        ctx context.Context,
        courseID, authorID uuid.UUID,
        filename string,
        reader io.Reader,
        size int64,
        contentType string,
) (string, error) <span class="cov8" title="1">{
        course, err := s.courseRepo.CourseByID(ctx, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return "", app_errors.ErrNotCourseAuthor
        }</span>

        <span class="cov8" title="1">if size &gt; maxLogoSizeBytes </span><span class="cov0" title="0">{
                return "", app_errors.ErrFileSize
        }</span>

        <span class="cov8" title="1">if contentType == "" </span><span class="cov0" title="0">{
                contentType = mime.TypeByExtension(strings.ToLower(filepath.Ext(filename)))
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(contentType, "image/") </span><span class="cov0" title="0">{
                return "", app_errors.ErrNotImage
        }</span>

        <span class="cov8" title="1">if course.LogoObjectKey != "" </span><span class="cov0" title="0">{
                if err := s.logoRepo.DeleteLogo(ctx, course.LogoObjectKey); err != nil </span><span class="cov0" title="0">{
                        s.log.ErrorErr("failed to delete previous logo", err)
                }</span>
        }

        <span class="cov8" title="1">objectKey, err := s.logoRepo.UploadLogo(ctx, courseID, filename, reader, size, contentType)
        if err != nil </span><span class="cov0" title="0">{
                s.log.ErrorErr("failed to upload logo to storage", err)
                return "", err
        }</span>

        <span class="cov8" title="1">if err = s.courseRepo.UpdateCourseLogo(ctx, courseID, objectKey); err != nil </span><span class="cov0" title="0">{
                s.log.ErrorErr("failed to save logo key to db", err)
                return "", err
        }</span>
        <span class="cov8" title="1">url, err := s.logoRepo.GetLogoURL(ctx, objectKey)
        if err != nil </span><span class="cov0" title="0">{
                s.log.ErrorErr("failed to get presigned URL", err)
                return "", err
        }</span>

        <span class="cov8" title="1">return url, nil</span>
}
func (s *CourseService) GetCourseLogoURL(ctx context.Context, courseID uuid.UUID) (string, error) <span class="cov0" title="0">{
        course, err := s.courseRepo.CourseByID(ctx, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if course.Status != models.StatusPublic </span><span class="cov0" title="0">{
                return "", app_errors.ErrCourseNotPublished
        }</span>
        <span class="cov0" title="0">if course.LogoObjectKey == "" </span><span class="cov0" title="0">{
                return "", app_errors.ErrImageNotFound
        }</span>
        <span class="cov0" title="0">url, err := s.logoRepo.GetLogoURL(ctx, course.LogoObjectKey)
        if err != nil </span><span class="cov0" title="0">{
                s.log.ErrorErr("failed to get logo URL", err)
                return "", err
        }</span>
        <span class="cov0" title="0">return url, nil</span>
}

func (s *CourseService) GetCourseStatus(ctx context.Context, id uuid.UUID) (string, error) <span class="cov0" title="0">{
        course, err := s.courseRepo.CourseByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return course.Status, nil</span>
}

func (s *CourseService) Subscribe(ctx context.Context, courseID, userID uuid.UUID) error <span class="cov0" title="0">{
        course, err := s.courseRepo.CourseByID(ctx, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if course.Status != models.StatusPublic </span><span class="cov0" title="0">{
                return app_errors.ErrCourseNotPublished
        }</span>

        <span class="cov0" title="0">return s.subscription.SubscribeCourse(ctx, courseID, userID)</span>
}

func (s *CourseService) GetSubscribedCourses(ctx context.Context, userID uuid.UUID) ([]models.CoursePreview, error) <span class="cov8" title="1">{
        courses, err := s.subscription.GetSubscribedCourses(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var previews []models.CoursePreview
        for _, course := range courses </span><span class="cov8" title="1">{
                var logoURL string
                if course.LogoObjectKey != "" </span><span class="cov8" title="1">{
                        logoURL, err = s.logoRepo.GetLogoURL(ctx, course.LogoObjectKey)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.ErrorErr("GetSubscribedCourses: failed to get logo URL", err)
                        }</span>
                }

                <span class="cov8" title="1">author, err := s.userRepo.UserByID(ctx, course.AuthorID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.ErrorErr("GetSubscribedCourses: failed to get author", err)
                        author = &amp;models.User{Username: ""}
                }</span>

                <span class="cov8" title="1">preview := models.CoursePreview{
                        ID:          course.ID,
                        Title:       course.Title,
                        Description: course.Description,
                        AuthorName:  author.Username,
                        LogoURL:     logoURL,
                        StarsCount:  course.StarsCount,
                }
                previews = append(previews, preview)</span>
        }

        <span class="cov8" title="1">return previews, nil</span>
}

func (s *CourseService) GetMyCourses(ctx context.Context, authorID uuid.UUID) ([]models.CoursePreview, error) <span class="cov0" title="0">{
        courses, err := s.courseRepo.ListCoursesByAuthor(ctx, authorID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var previews []models.CoursePreview
        for _, course := range courses </span><span class="cov0" title="0">{
                var logoURL string
                if course.LogoObjectKey != "" </span><span class="cov0" title="0">{
                        logoURL, err = s.logoRepo.GetLogoURL(ctx, course.LogoObjectKey)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.ErrorErr("GetMyCourses: failed to get logo URL", err)
                        }</span>
                }

                <span class="cov0" title="0">author, err := s.userRepo.UserByID(ctx, course.AuthorID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.ErrorErr("GetMyCourses: failed to get author", err)
                        author = &amp;models.User{Username: ""}
                }</span>

                <span class="cov0" title="0">preview := models.CoursePreview{
                        ID:          course.ID,
                        Title:       course.Title,
                        Description: course.Description,
                        AuthorName:  author.Username,
                        LogoURL:     logoURL,
                        StarsCount:  course.StarsCount,
                }
                previews = append(previews, preview)</span>
        }

        <span class="cov0" title="0">return previews, nil</span>
}

func (s *CourseService) GetRatingStatus(ctx context.Context, userID uuid.UUID) (map[uuid.UUID]bool, error) <span class="cov0" title="0">{

        courses, err := s.subscription.GetSubscribedCourses(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make(map[uuid.UUID]bool)
        for _, course := range courses </span><span class="cov0" title="0">{
                rated, err := s.ratingRepo.IsRated(ctx, course.ID, userID)
                if err != nil </span><span class="cov0" title="0">{
                        result[course.ID] = false
                }</span> else<span class="cov0" title="0"> {
                        result[course.ID] = rated
                }</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package lesson

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "SkillForge/pkg/logger"
        "context"
        "fmt"
        "io"

        "github.com/google/uuid"
)

type lessonRepo interface {
        CreateLesson(ctx context.Context, lesson models.Lesson) (*models.Lesson, error)
        CreateModule(ctx context.Context, module models.Module) (*models.Module, error)
        GetLessonByID(ctx context.Context, lessonID uuid.UUID) (models.Lesson, error)
        GetModuleByID(ctx context.Context, moduleID uuid.UUID) (models.Module, error)
        CourseContent(ctx context.Context, courseID uuid.UUID) ([]models.Contents, error)
        DeleteLessonAndUpdateOrder(ctx context.Context, lessonID, moduleID uuid.UUID, lessonOrder int) error
        DeleteModuleAndUpdateOrder(ctx context.Context, moduleID, courseID uuid.UUID, moduleOrder int) error
        GetMaxModuleOrder(ctx context.Context, courseID uuid.UUID) (int, error)
        GetMaxLessonOrder(ctx context.Context, moduleID uuid.UUID) (int, error)
        SwapLessons(ctx context.Context, lessonID1, lessonID2 uuid.UUID) error
        SwapModules(ctx context.Context, moduleID1, moduleID2 uuid.UUID) error
        CreateContent(ctx context.Context, content models.CourseContent) (*models.CourseContent, error)
        GetLessonDetail(ctx context.Context, lessonID uuid.UUID) (models.LessonDetail, error)
        UpsertContent(ctx context.Context, content models.CourseContent) (*models.CourseContent, error)
        LessonsByModule(ctx context.Context, moduleID uuid.UUID) ([]models.Lesson, error)
}
type courseRepo interface {
        CourseByID(ctx context.Context, id uuid.UUID) (*models.Course, error)
}

type mediaStorage interface {
        UploadPhoto(ctx context.Context, courseID uuid.UUID, filename string, reader io.Reader, size int64, contentType string) (objectKey string, err error)
        UploadVideo(ctx context.Context, courseID uuid.UUID, filename string, reader io.Reader, size int64, contentType string) (objectKey string, err error)
        GetPhotoURL(ctx context.Context, objectKey string) (string, error)
        GetVideoURL(ctx context.Context, objectKey string) (string, error)
        DeleteVideo(ctx context.Context, objectKey string) error
        DeletePhoto(ctx context.Context, objectKey string) error
}

type LessonService struct {
        log          logger.Log
        lessonRepo   lessonRepo
        courseRepo   courseRepo
        mediaStorage mediaStorage
}

func NewLessonService(l logger.Log, lessonRepo lessonRepo, courseRepo courseRepo, mediaStorage mediaStorage) *LessonService <span class="cov8" title="1">{
        return &amp;LessonService{
                log:          l,
                lessonRepo:   lessonRepo,
                courseRepo:   courseRepo,
                mediaStorage: mediaStorage,
        }
}</span>

func (s *LessonService) CreateContent(ctx context.Context, content models.CourseContent, authorID uuid.UUID) (*models.CourseContent, error) <span class="cov8" title="1">{
        lesson, err := s.lessonRepo.GetLessonByID(ctx, content.LessonID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">course, err := s.courseRepo.CourseByID(ctx, lesson.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return nil, app_errors.ErrNotCourseAuthor
        }</span>
        <span class="cov8" title="1">return s.lessonRepo.UpsertContent(ctx, content)</span>
}

func (s *LessonService) CreateMediaContent(ctx context.Context, lessonID uuid.UUID, mediaType, filename string, file io.Reader, size int64, contentType string, authorID uuid.UUID) (*models.CourseContent, error) <span class="cov8" title="1">{
        lesson, err := s.lessonRepo.GetLessonByID(ctx, lessonID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">course, err := s.courseRepo.CourseByID(ctx, lesson.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return nil, app_errors.ErrNotCourseAuthor
        }</span>

        <span class="cov8" title="1">var objectKey string
        switch mediaType </span>{
        case models.ContentTypeImage:<span class="cov0" title="0">
                objectKey, err = s.mediaStorage.UploadPhoto(ctx, lesson.CourseID, filename, file, size, contentType)</span>
        case models.ContentTypeVideo:<span class="cov8" title="1">
                objectKey, err = s.mediaStorage.UploadVideo(ctx, lesson.CourseID, filename, file, size, contentType)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported media type")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">content := models.CourseContent{
                LessonID:  lessonID,
                Type:      mediaType,
                ObjectKey: &amp;objectKey,
        }
        return s.lessonRepo.UpsertContent(ctx, content)</span>
}
func (s *LessonService) SwapLessons(ctx context.Context, lessonID1, lessonID2, authorID uuid.UUID) error <span class="cov8" title="1">{
        lesson1, err := s.lessonRepo.GetLessonByID(ctx, lessonID1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">lesson2, err := s.lessonRepo.GetLessonByID(ctx, lessonID2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if lesson1.ModuleID != lesson2.ModuleID </span><span class="cov0" title="0">{
                return fmt.Errorf("lessons belong to different modules")
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepo.CourseByID(ctx, lesson1.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return app_errors.ErrNotCourseAuthor
        }</span>

        <span class="cov8" title="1">return s.lessonRepo.SwapLessons(ctx, lessonID1, lessonID2)</span>
}

func (s *LessonService) SwapModules(ctx context.Context, moduleID1, moduleID2, courseID, authorID uuid.UUID) error <span class="cov8" title="1">{
        module1, err := s.lessonRepo.GetModuleByID(ctx, moduleID1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">module2, err := s.lessonRepo.GetModuleByID(ctx, moduleID2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if module1.CourseID != module2.CourseID </span><span class="cov0" title="0">{
                return fmt.Errorf("modules belong to different courses")
        }</span>
        <span class="cov8" title="1">if module1.CourseID != courseID </span><span class="cov0" title="0">{
                return fmt.Errorf("courseID mismatch")
        }</span>
        <span class="cov8" title="1">course, err := s.courseRepo.CourseByID(ctx, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return app_errors.ErrNotCourseAuthor
        }</span>

        <span class="cov8" title="1">return s.lessonRepo.SwapModules(ctx, moduleID1, moduleID2)</span>
}

func (s *LessonService) CreateLesson(ctx context.Context, lesson models.Lesson, authorID uuid.UUID) (*models.Lesson, error) <span class="cov0" title="0">{
        course, err := s.courseRepo.CourseByID(ctx, lesson.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return nil, app_errors.ErrNotCourseAuthor
        }</span>

        <span class="cov0" title="0">maxOrder, err := s.lessonRepo.GetMaxLessonOrder(ctx, lesson.ModuleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">lesson.LessonOrder = maxOrder + 1

        l, err := s.lessonRepo.CreateLesson(ctx, lesson)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return l, nil</span>
}

func (s *LessonService) CreateModule(ctx context.Context, module models.Module, authorID uuid.UUID) (*models.Module, error) <span class="cov8" title="1">{
        course, err := s.courseRepo.CourseByID(ctx, module.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return nil, app_errors.ErrNotCourseAuthor
        }</span>

        <span class="cov8" title="1">maxOrder, err := s.lessonRepo.GetMaxModuleOrder(ctx, module.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">module.Order = maxOrder + 1

        m, err := s.lessonRepo.CreateModule(ctx, module)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func (s *LessonService) CourseContent(ctx context.Context, courseID uuid.UUID) ([]models.Contents, error) <span class="cov8" title="1">{
        _, err := s.courseRepo.CourseByID(ctx, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return s.lessonRepo.CourseContent(ctx, courseID)</span>
}

func (s *LessonService) DeleteLesson(ctx context.Context, courseID, lessonID, moduleID, authorID uuid.UUID) error <span class="cov8" title="1">{
        course, err := s.courseRepo.CourseByID(ctx, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return app_errors.ErrNotCourseAuthor
        }</span>

        <span class="cov8" title="1">detail, err := s.lessonRepo.GetLessonDetail(ctx, lessonID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, content := range detail.Contents </span><span class="cov0" title="0">{
                if content.ObjectKey != nil </span><span class="cov0" title="0">{
                        switch content.Type </span>{
                        case models.ContentTypeImage:<span class="cov0" title="0">
                                if err := s.mediaStorage.DeletePhoto(ctx, *content.ObjectKey); err != nil </span><span class="cov0" title="0">{
                                        s.log.Error("failed to delete image from minio", err)
                                }</span>
                        case models.ContentTypeVideo:<span class="cov0" title="0">
                                if err := s.mediaStorage.DeleteVideo(ctx, *content.ObjectKey); err != nil </span><span class="cov0" title="0">{
                                        s.log.Error("failed to delete video from minio", err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return s.lessonRepo.DeleteLessonAndUpdateOrder(ctx, lessonID, moduleID, detail.Lesson.LessonOrder)</span>
}

func (s *LessonService) DeleteModule(ctx context.Context, courseID, moduleID, authorID uuid.UUID) error <span class="cov8" title="1">{
        course, err := s.courseRepo.CourseByID(ctx, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if course.AuthorID != authorID </span><span class="cov0" title="0">{
                return app_errors.ErrNotCourseAuthor
        }</span>

        <span class="cov8" title="1">module, err := s.lessonRepo.GetModuleByID(ctx, moduleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">lessons, err := s.lessonRepo.LessonsByModule(ctx, moduleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, lesson := range lessons </span><span class="cov8" title="1">{
                detail, err := s.lessonRepo.GetLessonDetail(ctx, lesson.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("failed to get lesson detail", err)
                        continue</span>
                }
                <span class="cov8" title="1">for _, content := range detail.Contents </span><span class="cov0" title="0">{
                        if content.ObjectKey != nil </span><span class="cov0" title="0">{
                                switch content.Type </span>{
                                case models.ContentTypeImage:<span class="cov0" title="0">
                                        if err := s.mediaStorage.DeletePhoto(ctx, *content.ObjectKey); err != nil </span><span class="cov0" title="0">{
                                                s.log.Error("failed to delete image from MinIO", err)
                                        }</span>
                                case models.ContentTypeVideo:<span class="cov0" title="0">
                                        if err := s.mediaStorage.DeleteVideo(ctx, *content.ObjectKey); err != nil </span><span class="cov0" title="0">{
                                                s.log.Error("failed to delete video from MinIO", err)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return s.lessonRepo.DeleteModuleAndUpdateOrder(ctx, moduleID, courseID, module.Order)</span>
}

func (s *LessonService) GetLessonDetail(ctx context.Context, lessonID uuid.UUID) (models.LessonDetail, error) <span class="cov8" title="1">{
        detail, err := s.lessonRepo.GetLessonDetail(ctx, lessonID)
        if err != nil </span><span class="cov0" title="0">{
                return detail, err
        }</span>
        <span class="cov8" title="1">for i := range detail.Contents </span><span class="cov8" title="1">{
                if detail.Contents[i].ObjectKey != nil </span><span class="cov0" title="0">{
                        switch detail.Contents[i].Type </span>{
                        case models.ContentTypeImage:<span class="cov0" title="0">
                                url, err := s.mediaStorage.GetPhotoURL(ctx, *detail.Contents[i].ObjectKey)
                                if err == nil </span><span class="cov0" title="0">{
                                        detail.Contents[i].ObjectKey = &amp;url
                                }</span>
                        case models.ContentTypeVideo:<span class="cov0" title="0">
                                url, err := s.mediaStorage.GetVideoURL(ctx, *detail.Contents[i].ObjectKey)
                                if err == nil </span><span class="cov0" title="0">{
                                        detail.Contents[i].ObjectKey = &amp;url
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return detail, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package elastic

import (
        "SkillForge/internal/models"
        custom_json "SkillForge/pkg/custom_serializer/json"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "github.com/elastic/go-elasticsearch/v8"
        "github.com/elastic/go-elasticsearch/v8/esapi"
        "github.com/google/uuid"
        "io"
)

type CourseSearchRepo struct {
        client *elasticsearch.Client
        index  string
}

func NewCourseSearchRepository(client *elasticsearch.Client, index string) *CourseSearchRepo <span class="cov0" title="0">{
        return &amp;CourseSearchRepo{client: client, index: index}
}</span>

func (r *CourseSearchRepo) CreateIndexIfNotExist(ctx context.Context) error <span class="cov0" title="0">{
        s := custom_json.New()
        existsReq := esapi.IndicesExistsRequest{Index: []string{r.index}}
        existsRes, err := existsReq.Do(ctx, r.client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error checking index existence: %w", err)
        }</span>
        <span class="cov0" title="0">defer existsRes.Body.Close()

        if existsRes.StatusCode == 404 </span><span class="cov0" title="0">{
                mapping := map[string]interface{}{
                        "settings": map[string]interface{}{ // custom analyzer
                                "analysis": map[string]interface{}{
                                        "analyzer": map[string]interface{}{
                                                "edge_ngram_analyzer": map[string]interface{}{
                                                        "tokenizer": "edge_ngram_tokenizer",
                                                        "filter":    []string{"lowercase"},
                                                },
                                        },
                                        "tokenizer": map[string]interface{}{
                                                "edge_ngram_tokenizer": map[string]interface{}{
                                                        "type":        "edge_ngram",
                                                        "min_gram":    2,
                                                        "max_gram":    20,
                                                        "token_chars": []string{"letter", "digit"},
                                                },
                                        },
                                },
                        },
                        "mappings": map[string]interface{}{
                                "properties": map[string]interface{}{
                                        "title": map[string]interface{}{
                                                "type":            "text",
                                                "analyzer":        "edge_ngram_analyzer",
                                                "search_analyzer": "standard",
                                        },
                                        "description": map[string]interface{}{
                                                "type":            "text",
                                                "analyzer":        "edge_ngram_analyzer",
                                                "search_analyzer": "standard",
                                        },
                                },
                        },
                }

                body, _ := s.Marshal(mapping)
                req := esapi.IndicesCreateRequest{Index: r.index, Body: bytes.NewReader(body)}
                res, err := req.Do(ctx, r.client)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create index: %w", err)
                }</span>
                <span class="cov0" title="0">defer res.Body.Close()
                if res.IsError() </span><span class="cov0" title="0">{
                        return fmt.Errorf("mapping creation failed: %s", res.String())
                }</span>
        }

        <span class="cov0" title="0">if existsRes.StatusCode &gt;= 300 &amp;&amp; existsRes.StatusCode != 404 </span><span class="cov0" title="0">{
                return fmt.Errorf("index existence check failed with status code %d", existsRes.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *CourseSearchRepo) Index(ctx context.Context, course models.Course) error <span class="cov0" title="0">{
        doc := map[string]interface{}{
                "title":       course.Title,
                "description": course.Description,
        }
        data, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal doc: %w", err)
        }</span>
        <span class="cov0" title="0">req := esapi.IndexRequest{
                Index:      r.index,
                DocumentID: course.ID.String(),
                Refresh:    "true",
                Body:       bytes.NewReader(data),
        }
        res, err := req.Do(ctx, r.client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("index request: %w", err)
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        if res.IsError() </span><span class="cov0" title="0">{
                return fmt.Errorf("index error: %s", res.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CourseSearchRepo) Update(ctx context.Context, course models.Course) error <span class="cov0" title="0">{
        partial := map[string]interface{}{"doc": map[string]interface{}{
                "title":       course.Title,
                "description": course.Description,
        }}
        body, err := json.Marshal(partial)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal update: %w", err)
        }</span>
        <span class="cov0" title="0">req := esapi.UpdateRequest{
                Index:      r.index,
                DocumentID: course.ID.String(),
                Body:       bytes.NewReader(body),
                Refresh:    "true",
        }
        res, err := req.Do(ctx, r.client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update request: %w", err)
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        if res.IsError() </span><span class="cov0" title="0">{
                return fmt.Errorf("update error: %s", res.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CourseSearchRepo) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        req := esapi.DeleteRequest{
                Index:      r.index,
                DocumentID: id.String(),
                Refresh:    "true",
        }
        res, err := req.Do(ctx, r.client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete request: %w", err)
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        if res.IsError() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete error: %s", res.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CourseSearchRepo) Count(ctx context.Context, query string) (int, error) <span class="cov0" title="0">{
        q := map[string]any{
                "query": map[string]interface{}{
                        "multi_match": map[string]interface{}{
                                "query":                query,
                                "fields":               []string{"title^3", "description"},
                                "type":                 "best_fields",
                                "fuzziness":            "AUTO",
                                "operator":             "or",
                                "minimum_should_match": "2&lt;75%",
                        },
                },
        }
        buf := &amp;bytes.Buffer{}
        if err := json.NewEncoder(buf).Encode(q); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("encode count body: %w", err)
        }</span>
        <span class="cov0" title="0">req := esapi.CountRequest{Index: []string{r.index}, Body: buf}
        res, err := req.Do(ctx, r.client)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("count request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        if res.IsError() </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(res.Body)
                return 0, fmt.Errorf("count error: %s", string(bodyBytes))
        }</span>
        <span class="cov0" title="0">var cntRes struct {
                Count int `json:"count"`
        }
        if err := json.NewDecoder(res.Body).Decode(&amp;cntRes); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("decode count response: %w", err)
        }</span>
        <span class="cov0" title="0">return cntRes.Count, nil</span>
}

func (r *CourseSearchRepo) Search(ctx context.Context, query string, size int) ([]uuid.UUID, error) <span class="cov0" title="0">{
        if size &lt;= 0 </span><span class="cov0" title="0">{
                size = 10
        }</span>
        <span class="cov0" title="0">q := map[string]interface{}{
                "query": map[string]interface{}{
                        "multi_match": map[string]interface{}{
                                "query":                query,
                                "fields":               []string{"title^3", "description"},
                                "type":                 "best_fields",
                                "fuzziness":            "AUTO",
                                "operator":             "or",
                                "minimum_should_match": "2&lt;75%",
                        },
                },
                "size": size,
        }
        buf := &amp;bytes.Buffer{}
        if err := json.NewEncoder(buf).Encode(q); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encode search body: %w", err)
        }</span>
        <span class="cov0" title="0">res, err := r.client.Search(
                r.client.Search.WithContext(ctx),
                r.client.Search.WithIndex(r.index),
                r.client.Search.WithBody(buf),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        if res.IsError() </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(res.Body)
                return nil, fmt.Errorf("search error: %s", string(bodyBytes))
        }</span>
        <span class="cov0" title="0">var esRes struct {
                Hits struct {
                        Hits []struct {
                                ID string `json:"_id"`
                        } `json:"hits"`
                } `json:"hits"`
        }
        if err := json.NewDecoder(res.Body).Decode(&amp;esRes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode response: %w", err)
        }</span>
        <span class="cov0" title="0">var ids []uuid.UUID
        for _, h := range esRes.Hits.Hits </span><span class="cov0" title="0">{
                if id, err := uuid.Parse(h.ID); err == nil </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
        }
        <span class="cov0" title="0">return ids, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package elastic

import (
        "fmt"
        "github.com/elastic/go-elasticsearch/v8"
)

const CourseIndex = "courses"

func NewElasticClient(password string, hosts []string) (*elasticsearch.Client, error) <span class="cov0" title="0">{
        client, err := elasticsearch.NewClient(elasticsearch.Config{
                Addresses: hosts,
                Username:  "elastic",
                Password:  password,
        })
        res, err := client.Info()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("elastic: cannot connect to cluster: %w", err)
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        if res.IsError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("elastic: cluster returned error: %s", res.String())
        }</span>
        <span class="cov0" title="0">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package minio_storage

import (
        "context"
        "fmt"
        "github.com/google/uuid"
        "github.com/minio/minio-go/v7"
        "io"
        "mime"
        "net/url"
        "path/filepath"
        "time"
)

type LogoStorage struct {
        storage      *MinioStorage
        bucket       string
        presignedTTL time.Duration
}

func NewLogoStorage(storage *MinioStorage, bucketName string, presignedTTL time.Duration) (*LogoStorage, error) <span class="cov0" title="0">{
        exists, err := storage.client.BucketExists(context.Background(), bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                if err = storage.client.MakeBucket(context.Background(), bucketName, minio.MakeBucketOptions{}); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return &amp;LogoStorage{storage: storage, bucket: bucketName, presignedTTL: presignedTTL}, nil</span>
}

func (s *LogoStorage) UploadLogo(
        ctx context.Context,
        courseID uuid.UUID,
        filename string,
        reader io.Reader,
        size int64,
        contentType string,
) (objectKey string, err error) <span class="cov0" title="0">{
        ext := filepath.Ext(filename)
        if ext == "" </span><span class="cov0" title="0">{
                ext = ".bin"
        }</span>

        <span class="cov0" title="0">objectKey = fmt.Sprintf("courses/%s/logo%s", courseID.String(), ext)

        if contentType == "" </span><span class="cov0" title="0">{
                contentType = mime.TypeByExtension(ext)
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = "application/octet-stream"
                }</span>
        }

        <span class="cov0" title="0">_, err = s.storage.client.PutObject(
                ctx,
                s.bucket,
                objectKey,
                reader,
                size,
                minio.PutObjectOptions{ContentType: contentType},
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return objectKey, nil</span>
}

func (s *LogoStorage) GetLogoURL(ctx context.Context, objectKey string) (string, error) <span class="cov0" title="0">{
        reqParams := make(url.Values)
        presignedURL, err := s.storage.client.PresignedGetObject(
                ctx,
                s.bucket,
                objectKey,
                s.presignedTTL,
                reqParams,
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return presignedURL.String(), nil</span>
}

func (s *LogoStorage) DeleteLogo(ctx context.Context, objectKey string) error <span class="cov0" title="0">{
        return s.storage.client.RemoveObject(ctx, s.bucket, objectKey, minio.RemoveObjectOptions{})
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package minio_storage

import (
        "context"
        "fmt"
        "github.com/google/uuid"
        "github.com/minio/minio-go/v7"
        "io"
        "mime"
        "net/url"
        "path/filepath"
        "time"
)

type LessonStorage struct {
        storage      *MinioStorage
        bucket       string
        presignedTTL time.Duration
}

func NewLessonStorage(storage *MinioStorage, bucketName string, presignedTTL time.Duration) (*LessonStorage, error) <span class="cov0" title="0">{
        exists, err := storage.client.BucketExists(context.Background(), bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                if err = storage.client.MakeBucket(context.Background(), bucketName, minio.MakeBucketOptions{}); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return &amp;LessonStorage{storage: storage, bucket: bucketName, presignedTTL: presignedTTL}, nil</span>
}

func (s *LessonStorage) UploadPhoto(
        ctx context.Context,
        courseID uuid.UUID,
        filename string,
        reader io.Reader,
        size int64,
        contentType string,
) (objectKey string, err error) <span class="cov0" title="0">{
        ext := filepath.Ext(filename)
        if ext == "" </span><span class="cov0" title="0">{
                ext = ".bin"
        }</span>

        <span class="cov0" title="0">objectKey = fmt.Sprintf("lessons/%s/photo%s", courseID.String(), ext)

        if contentType == "" </span><span class="cov0" title="0">{
                contentType = mime.TypeByExtension(ext)
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = "application/octet-stream"
                }</span>
        }

        <span class="cov0" title="0">_, err = s.storage.client.PutObject(
                ctx,
                s.bucket,
                objectKey,
                reader,
                size,
                minio.PutObjectOptions{ContentType: contentType},
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return objectKey, nil</span>
}

func (s *LessonStorage) GetPhotoURL(ctx context.Context, objectKey string) (string, error) <span class="cov0" title="0">{
        reqParams := make(url.Values)
        url, err := s.storage.client.PresignedGetObject(
                ctx,
                s.bucket,
                objectKey,
                s.presignedTTL,
                reqParams,
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return url.String(), nil</span>
}

func (s *LessonStorage) DeletePhoto(ctx context.Context, objectKey string) error <span class="cov0" title="0">{
        return s.storage.client.RemoveObject(ctx, s.bucket, objectKey, minio.RemoveObjectOptions{})
}</span>

func (s *LessonStorage) UploadVideo(
        ctx context.Context,
        courseID uuid.UUID,
        filename string,
        reader io.Reader,
        size int64,
        contentType string,
) (objectKey string, err error) <span class="cov0" title="0">{
        ext := filepath.Ext(filename)
        if ext == "" </span><span class="cov0" title="0">{
                ext = ".bin"
        }</span>

        <span class="cov0" title="0">objectKey = fmt.Sprintf("lessons/%s/video%s", courseID.String(), ext)

        if contentType == "" </span><span class="cov0" title="0">{
                contentType = mime.TypeByExtension(ext)
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = "application/octet-stream"
                }</span>
        }

        <span class="cov0" title="0">_, err = s.storage.client.PutObject(
                ctx,
                s.bucket,
                objectKey,
                reader,
                size,
                minio.PutObjectOptions{ContentType: contentType},
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return objectKey, nil</span>
}

func (s *LessonStorage) GetVideoURL(ctx context.Context, objectKey string) (string, error) <span class="cov0" title="0">{
        reqParams := make(url.Values)
        url, err := s.storage.client.PresignedGetObject(
                ctx,
                s.bucket,
                objectKey,
                s.presignedTTL,
                reqParams,
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return url.String(), nil</span>
}

func (s *LessonStorage) DeleteVideo(ctx context.Context, objectKey string) error <span class="cov0" title="0">{
        return s.storage.client.RemoveObject(ctx, s.bucket, objectKey, minio.RemoveObjectOptions{})
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package minio_storage

import (
        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
)

type MinioStorage struct {
        client *minio.Client
}

func NewMinioStorage(endpoint, accessKey, secretKey string, useSSL bool) (*MinioStorage, error) <span class="cov0" title="0">{
        client, err := minio.New(endpoint, &amp;minio.Options{
                Creds:  credentials.NewStaticV4(accessKey, secretKey, ""),
                Secure: useSSL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;MinioStorage{client: client}, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package postgres

import (
        "SkillForge/internal/models"
        "context"
        "fmt"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "time"
)

type ContentPostgres struct {
        db *pgxpool.Pool
}

func NewContentPostgres(db *pgxpool.Pool) *ContentPostgres <span class="cov8" title="1">{
        return &amp;ContentPostgres{db: db}
}</span>

func (r *ContentPostgres) CreateContent(ctx context.Context, c models.CourseContent) (models.CourseContent, error) <span class="cov8" title="1">{
        query := `
    INSERT INTO contents (
        id, lesson_id, type, order_num,
        text, object_key, quiz_json, created_at, updated_at
    ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
    `
        now := time.Now().UTC()
        if c.ID == uuid.Nil </span><span class="cov8" title="1">{
                c.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">c.CreatedAt = now
        c.UpdatedAt = now

        _, err := r.db.Exec(ctx, query,
                c.ID, c.LessonID, c.Type, c.Order,
                c.Text, c.ObjectKey, c.QuizJSON,
                c.CreatedAt, c.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return models.CourseContent{}, fmt.Errorf("failed to insert content: %w", err)
        }</span>
        <span class="cov8" title="1">return c, nil</span>
}

func (r *ContentPostgres) GetContentsByLesson(ctx context.Context, lessonID uuid.UUID) ([]models.CourseContent, error) <span class="cov8" title="1">{
        query := `
    SELECT id, lesson_id, type, order_num, text, object_key, quiz_json, created_at, updated_at
      FROM contents
     WHERE lesson_id = $1
  ORDER BY order_num
    `
        rows, err := r.db.Query(ctx, query, lessonID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query contents: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var contents []models.CourseContent
        for rows.Next() </span><span class="cov8" title="1">{
                var c models.CourseContent
                if err := rows.Scan(
                        &amp;c.ID, &amp;c.LessonID, &amp;c.Type, &amp;c.Order,
                        &amp;c.Text, &amp;c.ObjectKey, &amp;c.QuizJSON,
                        &amp;c.CreatedAt, &amp;c.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">contents = append(contents, c)</span>
        }
        <span class="cov8" title="1">return contents, nil</span>
}

func (r *ContentPostgres) UpdateContent(ctx context.Context, c models.CourseContent) (models.CourseContent, error) <span class="cov8" title="1">{
        query := `
    UPDATE contents SET
        type = $1,
        order_num = $2,
        text = $3,
        object_key = $4,
        quiz_json = $5,
        updated_at = $6
     WHERE id = $7
    `
        c.UpdatedAt = time.Now().UTC()
        _, err := r.db.Exec(ctx, query,
                c.Type, c.Order, c.Text, c.ObjectKey, c.QuizJSON, c.UpdatedAt, c.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return models.CourseContent{}, fmt.Errorf("failed to update content: %w", err)
        }</span>
        <span class="cov8" title="1">return c, nil</span>
}

func (r *ContentPostgres) DeleteContent(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        query := `DELETE FROM contents WHERE id = $1`
        _, err := r.db.Exec(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete content: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package postgres

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type CoursePostgres struct {
        db *pgxpool.Pool
}

func NewCoursePostgres(db *pgxpool.Pool) *CoursePostgres <span class="cov8" title="1">{
        return &amp;CoursePostgres{db: db}
}</span>

func (r *CoursePostgres) NewCourse(ctx context.Context, course *models.Course) (uuid.UUID, error) <span class="cov8" title="1">{
        if course.ID == uuid.Nil </span><span class="cov8" title="1">{
                course.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">now := time.Now().UTC()
        course.CreatedAt = now
        course.UpdatedAt = now
        query := `
                INSERT INTO courses (
                        id, title, description, logo_object_key, created_at, updated_at,
                        author_id, status, stars_count
                ) VALUES (
                        $1, $2, $3, $4, $5, $6,
                        $7, $8, $9
                )
                RETURNING id, created_at, updated_at
        `
        var returnedID uuid.UUID
        var returnedCreated, returnedUpdated time.Time
        err := r.db.QueryRow(
                ctx,
                query,
                course.ID,
                course.Title,
                course.Description,
                course.LogoObjectKey,
                course.CreatedAt,
                course.UpdatedAt,
                course.AuthorID,
                course.Status,
                course.StarsCount,
        ).Scan(&amp;returnedID, &amp;returnedCreated, &amp;returnedUpdated)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>
        <span class="cov8" title="1">course.ID = returnedID
        course.CreatedAt = returnedCreated
        course.UpdatedAt = returnedUpdated
        return returnedID, nil</span>
}

func (r *CoursePostgres) CourseByID(ctx context.Context, id uuid.UUID) (*models.Course, error) <span class="cov8" title="1">{
        const query = `
        SELECT 
            id,
            title,
            description,
            logo_object_key,
            created_at,
            updated_at,
            author_id,
            status,
            stars_count
        FROM courses
        WHERE id = $1
    `
        course := &amp;models.Course{}
        row := r.db.QueryRow(ctx, query, id)
        err := row.Scan(
                &amp;course.ID,
                &amp;course.Title,
                &amp;course.Description,
                &amp;course.LogoObjectKey,
                &amp;course.CreatedAt,
                &amp;course.UpdatedAt,
                &amp;course.AuthorID,
                &amp;course.Status,
                &amp;course.StarsCount,
        )
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, app_errors.ErrCourseNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return course, nil</span>
}

func (r *CoursePostgres) CountPublicCourses(ctx context.Context) (int, error) <span class="cov0" title="0">{
        const query = `
        SELECT COUNT(*) 
          FROM courses 
         WHERE status = $1
    `
        var cnt int
        err := r.db.QueryRow(ctx, query, models.StatusPublic).Scan(&amp;cnt)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("CountPublicCourses: %w", err)
        }</span>
        <span class="cov0" title="0">return cnt, nil</span>
}

func (r *CoursePostgres) ListPublicCourses(ctx context.Context, limit int, offset int) ([]models.Course, error) <span class="cov0" title="0">{
        const query = `
   SELECT 
  id, title, description, logo_object_key, created_at, updated_at,
  author_id, status, stars_count
        FROM courses
        WHERE status = $1
        ORDER BY created_at DESC
        LIMIT $2
        OFFSET $3
    `

        rows, err := r.db.Query(ctx, query, models.StatusPublic, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ListPublicCourses: unable to query courses: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var courses []models.Course
        for rows.Next() </span><span class="cov0" title="0">{
                var c models.Course
                if err := rows.Scan(
                        &amp;c.ID,
                        &amp;c.Title,
                        &amp;c.Description,
                        &amp;c.LogoObjectKey,
                        &amp;c.CreatedAt,
                        &amp;c.UpdatedAt,
                        &amp;c.AuthorID,
                        &amp;c.Status,
                        &amp;c.StarsCount,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ListPublicCourses: scan error: %w", err)
                }</span>
                <span class="cov0" title="0">courses = append(courses, c)</span>
        }
        <span class="cov0" title="0">if rows.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ListPublicCourses: rows iteration error: %w", rows.Err())
        }</span>

        <span class="cov0" title="0">return courses, nil</span>
}

func (r *CoursePostgres) ChangeStatus(ctx context.Context, id uuid.UUID, status string) error <span class="cov8" title="1">{
        const query = `
        UPDATE courses
           SET status     = $2,
               updated_at = NOW()
         WHERE id = $1
    `
        cmdTag, err := r.db.Exec(ctx, query, id, status)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if cmdTag.RowsAffected() == 0 </span><span class="cov8" title="1">{
                return app_errors.ErrCourseNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *CoursePostgres) UpdateCourseLogo(ctx context.Context, courseID uuid.UUID, logoObjectKey string) error <span class="cov8" title="1">{
        const query = `
                UPDATE courses
                   SET logo_object_key = $2,
                       updated_at      = NOW()
                 WHERE id = $1
        `
        cmd, err := r.db.Exec(ctx, query, courseID, logoObjectKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if cmd.RowsAffected() == 0 </span><span class="cov8" title="1">{
                return app_errors.ErrCourseNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *CoursePostgres) ListCoursesByAuthor(ctx context.Context, authorID uuid.UUID) ([]models.Course, error) <span class="cov0" title="0">{
        query := `
        SELECT id, title, description, logo_object_key, created_at, updated_at, author_id, status, stars_count
        FROM courses
        WHERE author_id = $1
        ORDER BY created_at DESC
    `
        rows, err := r.db.Query(ctx, query, authorID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query courses by author: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var courses []models.Course
        for rows.Next() </span><span class="cov0" title="0">{
                var c models.Course
                if err := rows.Scan(&amp;c.ID, &amp;c.Title, &amp;c.Description, &amp;c.LogoObjectKey,
                        &amp;c.CreatedAt, &amp;c.UpdatedAt, &amp;c.AuthorID, &amp;c.Status, &amp;c.StarsCount); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">courses = append(courses, c)</span>
        }
        <span class="cov0" title="0">return courses, nil</span>
}

func (r *CoursePostgres) IncrementStars(ctx context.Context, courseID uuid.UUID) error <span class="cov0" title="0">{
        _, err := r.db.Exec(ctx, `
        UPDATE courses 
           SET stars_count = stars_count + 1
         WHERE id = $1
    `, courseID)
        return err
}</span>

func (r *CoursePostgres) DecrementStars(ctx context.Context, courseID uuid.UUID) error <span class="cov0" title="0">{
        _, err := r.db.Exec(ctx, `
        UPDATE courses 
           SET stars_count = stars_count - 1
         WHERE id = $1 AND stars_count &gt; 0
    `, courseID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package postgres

import (
        "SkillForge/internal/app_errors"
        "context"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

type CourseRatingPostgres struct {
        db *pgxpool.Pool
}

func NewCourseRatingPostgres(db *pgxpool.Pool) *CourseRatingPostgres <span class="cov0" title="0">{
        return &amp;CourseRatingPostgres{db: db}
}</span>

func (r *CourseRatingPostgres) AddRating(ctx context.Context, courseID, userID uuid.UUID) error <span class="cov0" title="0">{
        var exists bool
        err := r.db.QueryRow(ctx, `
        SELECT EXISTS(
            SELECT 1 FROM course_ratings WHERE course_id=$1 AND user_id=$2
        )
    `, courseID, userID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return app_errors.ErrAlreadyRated
        }</span>
        <span class="cov0" title="0">_, err = r.db.Exec(ctx, `
        INSERT INTO course_ratings (course_id, user_id)
        VALUES ($1, $2)
    `, courseID, userID)
        return err</span>
}

func (r *CourseRatingPostgres) RemoveRating(ctx context.Context, courseID, userID uuid.UUID) error <span class="cov0" title="0">{
        var exists bool
        err := r.db.QueryRow(ctx, `
        SELECT EXISTS(
            SELECT 1 FROM course_ratings WHERE course_id=$1 AND user_id=$2
        )
    `, courseID, userID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return app_errors.ErrNotRated
        }</span>
        <span class="cov0" title="0">_, err = r.db.Exec(ctx, `
        DELETE FROM course_ratings WHERE course_id=$1 AND user_id=$2
    `, courseID, userID)
        return err</span>
}

func (r *CourseRatingPostgres) IsRated(ctx context.Context, courseID, userID uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var exists bool
        err := r.db.QueryRow(ctx, `
        SELECT EXISTS(
            SELECT 1 FROM course_ratings WHERE course_id=$1 AND user_id=$2
        )
    `, courseID, userID).Scan(&amp;exists)
        return exists, err
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package postgres

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

type LessonPostgres struct {
        db *pgxpool.Pool
}

func NewLessonPostgres(db *pgxpool.Pool) *LessonPostgres <span class="cov8" title="1">{
        return &amp;LessonPostgres{db: db}
}</span>

func (r *LessonPostgres) CreateLesson(ctx context.Context, lesson models.Lesson) (*models.Lesson, error) <span class="cov8" title="1">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback(ctx)

        updateQuery := `
        UPDATE lessons SET lesson_order = lesson_order + 1
         WHERE module_id = $1 AND lesson_order &gt;= $2
    `
        _, err = tx.Exec(ctx, updateQuery, lesson.ModuleID, lesson.LessonOrder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC()
        if lesson.ID == uuid.Nil </span><span class="cov8" title="1">{
                lesson.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">lesson.CreatedAt = now
        lesson.UpdatedAt = now

        insertQuery := `
    INSERT INTO lessons (
        id, course_id, module_id,
        lesson_title, lesson_order, created_at, updated_at
    ) VALUES ($1, $2, $3, $4, $5, $6, $7)
    `
        _, err = tx.Exec(ctx, insertQuery,
                lesson.ID, lesson.CourseID, lesson.ModuleID,
                lesson.LessonTitle, lesson.LessonOrder, lesson.CreatedAt, lesson.UpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if pgErr := UnwrapPgError(err); pgErr != nil &amp;&amp; pgErr.Code == "23505" </span><span class="cov8" title="1">{
                        return nil, app_errors.ErrDuplicateLesson
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;lesson, nil</span>
}

func (r *LessonPostgres) GetLessonByID(ctx context.Context, id uuid.UUID) (models.Lesson, error) <span class="cov0" title="0">{
        var lesson models.Lesson
        query := `
    SELECT id, course_id, module_id,
           lesson_title, lesson_order, created_at, updated_at
      FROM lessons
     WHERE id = $1
    `
        row := r.db.QueryRow(ctx, query, id)
        err := row.Scan(
                &amp;lesson.ID, &amp;lesson.CourseID, &amp;lesson.ModuleID,
                &amp;lesson.LessonTitle, &amp;lesson.LessonOrder, &amp;lesson.CreatedAt, &amp;lesson.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return models.Lesson{}, fmt.Errorf("lesson not found: %w", err)
        }</span>
        <span class="cov0" title="0">return lesson, nil</span>
}

func (r *LessonPostgres) GetMaxLessonOrder(ctx context.Context, moduleID uuid.UUID) (int, error) <span class="cov8" title="1">{
        var max int
        query := `SELECT COALESCE(MAX(lesson_order), 0) FROM lessons WHERE module_id = $1`
        err := r.db.QueryRow(ctx, query, moduleID).Scan(&amp;max)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get max lesson order: %w", err)
        }</span>
        <span class="cov8" title="1">return max, nil</span>
}

func (r *LessonPostgres) CreateModule(ctx context.Context, module models.Module) (*models.Module, error) <span class="cov8" title="1">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback(ctx)

        //  order  ,  
        updateQuery := `
        UPDATE modules SET module_order = module_order + 1
         WHERE course_id = $1 AND module_order &gt;= $2
    `
        _, err = tx.Exec(ctx, updateQuery, module.CourseID, module.Order)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC()
        if module.ID == uuid.Nil </span><span class="cov8" title="1">{
                module.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">module.CreatedAt = now
        module.UpdatedAt = now

        insertQuery := `
    INSERT INTO modules (
        id, course_id, title, module_order, created_at, updated_at
    ) VALUES ($1, $2, $3, $4, $5, $6)
    `
        _, err = tx.Exec(ctx, insertQuery,
                module.ID, module.CourseID, module.Title,
                module.Order, module.CreatedAt, module.UpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if pgErr := UnwrapPgError(err); pgErr != nil &amp;&amp; pgErr.Code == "23505" </span><span class="cov8" title="1">{
                        return nil, app_errors.ErrDuplicateModule
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;module, nil</span>
}

func (r *LessonPostgres) GetMaxModuleOrder(ctx context.Context, courseID uuid.UUID) (int, error) <span class="cov8" title="1">{
        var max int
        query := `SELECT COALESCE(MAX(module_order), 0) FROM modules WHERE course_id = $1`
        err := r.db.QueryRow(ctx, query, courseID).Scan(&amp;max)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get max module order: %w", err)
        }</span>
        <span class="cov8" title="1">return max, nil</span>
}

func (r *LessonPostgres) DeleteLessonAndUpdateOrder(ctx context.Context, lessonID, moduleID uuid.UUID, lessonOrder int) error <span class="cov0" title="0">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback(ctx)

        deleteQuery := `DELETE FROM lessons WHERE id = $1`
        _, err = tx.Exec(ctx, deleteQuery, lessonID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">updateQuery := `
        UPDATE lessons SET lesson_order = lesson_order - 1
         WHERE module_id = $1 AND lesson_order &gt; $2
    `
        _, err = tx.Exec(ctx, updateQuery, moduleID, lessonOrder)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit(ctx)</span>
}

func (r *LessonPostgres) DeleteModuleAndUpdateOrder(ctx context.Context, moduleID, courseID uuid.UUID, moduleOrder int) error <span class="cov0" title="0">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback(ctx)

        deleteLessonsQuery := `DELETE FROM lessons WHERE module_id = $1`
        _, err = tx.Exec(ctx, deleteLessonsQuery, moduleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">deleteModuleQuery := `DELETE FROM modules WHERE id = $1`
        _, err = tx.Exec(ctx, deleteModuleQuery, moduleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">updateQuery := `
        UPDATE modules SET module_order = module_order - 1
         WHERE course_id = $1 AND module_order &gt; $2
    `
        _, err = tx.Exec(ctx, updateQuery, courseID, moduleOrder)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit(ctx)</span>
}

func (r *LessonPostgres) CourseContent(ctx context.Context, courseID uuid.UUID) ([]models.Contents, error) <span class="cov8" title="1">{
        modulesQuery := `
        SELECT id, course_id, title, module_order, created_at, updated_at
        FROM modules
        WHERE course_id = $1
        ORDER BY module_order
    `
        rows, err := r.db.Query(ctx, modulesQuery, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query modules: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var modules []models.Module
        for rows.Next() </span><span class="cov8" title="1">{
                var m models.Module
                if err := rows.Scan(&amp;m.ID, &amp;m.CourseID, &amp;m.Title, &amp;m.Order, &amp;m.CreatedAt, &amp;m.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">modules = append(modules, m)</span>
        }

        <span class="cov8" title="1">lessonsQuery := `
        SELECT id, course_id, module_id, lesson_title, lesson_order, created_at, updated_at
        FROM lessons
        WHERE course_id = $1
        ORDER BY module_id, lesson_order
    `
        lessonRows, err := r.db.Query(ctx, lessonsQuery, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query lessons: %w", err)
        }</span>
        <span class="cov8" title="1">defer lessonRows.Close()

        lessonsByModule := make(map[uuid.UUID][]models.Lesson)
        for lessonRows.Next() </span><span class="cov8" title="1">{
                var l models.Lesson
                if err := lessonRows.Scan(&amp;l.ID, &amp;l.CourseID, &amp;l.ModuleID, &amp;l.LessonTitle, &amp;l.LessonOrder, &amp;l.CreatedAt, &amp;l.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">lessonsByModule[l.ModuleID] = append(lessonsByModule[l.ModuleID], l)</span>
        }

        <span class="cov8" title="1">var content []models.Contents
        for _, mod := range modules </span><span class="cov8" title="1">{
                ml := models.Contents{
                        Module:  mod,
                        Lessons: lessonsByModule[mod.ID],
                }
                content = append(content, ml)
        }</span>
        <span class="cov8" title="1">return content, nil</span>
}

func (r *LessonPostgres) GetModuleByID(ctx context.Context, moduleID uuid.UUID) (models.Module, error) <span class="cov0" title="0">{
        var module models.Module
        query := `
        SELECT id, course_id, title, module_order, created_at, updated_at
          FROM modules
         WHERE id = $1
    `
        row := r.db.QueryRow(ctx, query, moduleID)
        err := row.Scan(&amp;module.ID, &amp;module.CourseID, &amp;module.Title, &amp;module.Order, &amp;module.CreatedAt, &amp;module.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return models.Module{}, fmt.Errorf("module not found: %w", err)
        }</span>
        <span class="cov0" title="0">return module, nil</span>
}

func (r *LessonPostgres) LessonsByCourse(ctx context.Context, courseID uuid.UUID) ([]models.Lesson, error) <span class="cov0" title="0">{
        query := `
        SELECT id, course_id, module_id, lesson_title, lesson_order, created_at, updated_at
          FROM lessons
         WHERE course_id = $1
         ORDER BY lesson_order
    `
        rows, err := r.db.Query(ctx, query, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query lessons by course: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var lessons []models.Lesson
        for rows.Next() </span><span class="cov0" title="0">{
                var l models.Lesson
                if err := rows.Scan(
                        &amp;l.ID, &amp;l.CourseID, &amp;l.ModuleID, &amp;l.LessonTitle, &amp;l.LessonOrder, &amp;l.CreatedAt, &amp;l.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">lessons = append(lessons, l)</span>
        }
        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return lessons, nil</span>
}
func (r *LessonPostgres) SwapLessons(ctx context.Context, lessonID1, lessonID2 uuid.UUID) error <span class="cov8" title="1">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback(ctx)

        var order1, order2 int
        query := `SELECT lesson_order FROM lessons WHERE id = $1`
        if err := tx.QueryRow(ctx, query, lessonID1).Scan(&amp;order1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get order for lesson1: %w", err)
        }</span>
        <span class="cov8" title="1">if err := tx.QueryRow(ctx, query, lessonID2).Scan(&amp;order2); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get order for lesson2: %w", err)
        }</span>

        <span class="cov8" title="1">updateQuery := `UPDATE lessons SET lesson_order = $1 WHERE id = $2`
        tempOrder := -1
        if _, err := tx.Exec(ctx, updateQuery, tempOrder, lessonID1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update lesson1 to temp order: %w", err)
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec(ctx, updateQuery, order1, lessonID2); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update lesson2 order: %w", err)
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec(ctx, updateQuery, order2, lessonID1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update lesson1 order: %w", err)
        }</span>

        <span class="cov8" title="1">return tx.Commit(ctx)</span>
}

func (r *LessonPostgres) SwapModules(ctx context.Context, moduleID1, moduleID2 uuid.UUID) error <span class="cov8" title="1">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback(ctx)

        var order1, order2 int
        query := `SELECT module_order FROM modules WHERE id = $1`
        if err := tx.QueryRow(ctx, query, moduleID1).Scan(&amp;order1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get order for module1: %w", err)
        }</span>
        <span class="cov8" title="1">if err := tx.QueryRow(ctx, query, moduleID2).Scan(&amp;order2); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get order for module2: %w", err)
        }</span>

        <span class="cov8" title="1">updateQuery := `UPDATE modules SET module_order = $1 WHERE id = $2`
        tempOrder := -1
        if _, err := tx.Exec(ctx, updateQuery, tempOrder, moduleID1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update module1 to temp order: %w", err)
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec(ctx, updateQuery, order1, moduleID2); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update module2 order: %w", err)
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec(ctx, updateQuery, order2, moduleID1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update module1 order: %w", err)
        }</span>

        <span class="cov8" title="1">return tx.Commit(ctx)</span>
}

func (r *LessonPostgres) CreateContent(ctx context.Context, content models.CourseContent) (*models.CourseContent, error) <span class="cov0" title="0">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback(ctx)

        var max int
        err = tx.QueryRow(ctx, `SELECT COALESCE(MAX(order_num), 0) FROM contents WHERE lesson_id = $1`, content.LessonID).Scan(&amp;max)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get max order_num: %w", err)
        }</span>
        <span class="cov0" title="0">content.Order = max + 1

        now := time.Now().UTC()
        content.CreatedAt = now
        content.UpdatedAt = now
        if content.ID == uuid.Nil </span><span class="cov0" title="0">{
                content.ID = uuid.New()
        }</span>

        <span class="cov0" title="0">insertQuery := `
    INSERT INTO contents (
        id, lesson_id, type, order_num, text, object_key, quiz_json, created_at, updated_at
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `
        _, err = tx.Exec(ctx, insertQuery,
                content.ID, content.LessonID, content.Type, content.Order,
                content.Text, content.ObjectKey, content.QuizJSON,
                content.CreatedAt, content.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;content, nil</span>
}

func (r *LessonPostgres) GetLessonDetail(ctx context.Context, lessonID uuid.UUID) (models.LessonDetail, error) <span class="cov8" title="1">{
        var detail models.LessonDetail
        query := `
        SELECT id, course_id, module_id, lesson_title, lesson_order, created_at, updated_at 
          FROM lessons 
         WHERE id = $1
    `
        row := r.db.QueryRow(ctx, query, lessonID)
        if err := row.Scan(&amp;detail.Lesson.ID, &amp;detail.Lesson.CourseID, &amp;detail.Lesson.ModuleID, &amp;detail.Lesson.LessonTitle, &amp;detail.Lesson.LessonOrder, &amp;detail.Lesson.CreatedAt, &amp;detail.Lesson.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                return detail, fmt.Errorf("lesson not found: %w", err)
        }</span>
        <span class="cov8" title="1">contentsQuery := `
        SELECT id, lesson_id, type, order_num, text, object_key, quiz_json, created_at, updated_at 
          FROM contents 
         WHERE lesson_id = $1 
         ORDER BY order_num
    `
        rows, err := r.db.Query(ctx, contentsQuery, lessonID)
        if err != nil </span><span class="cov0" title="0">{
                return detail, fmt.Errorf("failed to query contents: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var contents []models.CourseContent
        for rows.Next() </span><span class="cov8" title="1">{
                var c models.CourseContent
                if err := rows.Scan(&amp;c.ID, &amp;c.LessonID, &amp;c.Type, &amp;c.Order, &amp;c.Text, &amp;c.ObjectKey, &amp;c.QuizJSON, &amp;c.CreatedAt, &amp;c.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return detail, err
                }</span>
                <span class="cov8" title="1">contents = append(contents, c)</span>
        }
        <span class="cov8" title="1">detail.Contents = contents
        return detail, nil</span>
}

func (r *LessonPostgres) LessonsByModule(ctx context.Context, moduleID uuid.UUID) ([]models.Lesson, error) <span class="cov8" title="1">{
        query := `
        SELECT id, course_id, module_id, lesson_title, lesson_order, created_at, updated_at
          FROM lessons
         WHERE module_id = $1
         ORDER BY lesson_order
    `
        rows, err := r.db.Query(ctx, query, moduleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query lessons by module: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var lessons []models.Lesson
        for rows.Next() </span><span class="cov8" title="1">{
                var lesson models.Lesson
                if err := rows.Scan(&amp;lesson.ID, &amp;lesson.CourseID, &amp;lesson.ModuleID, &amp;lesson.LessonTitle, &amp;lesson.LessonOrder, &amp;lesson.CreatedAt, &amp;lesson.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">lessons = append(lessons, lesson)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return lessons, nil</span>
}

func (r *LessonPostgres) UpsertContent(ctx context.Context, content models.CourseContent) (*models.CourseContent, error) <span class="cov0" title="0">{
        var existingID uuid.UUID
        err := r.db.QueryRow(ctx, `SELECT id FROM contents WHERE lesson_id = $1 LIMIT 1`, content.LessonID).Scan(&amp;existingID)
        now := time.Now().UTC()
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "no rows in result set" || err.Error() == "pg: no rows in result set" </span><span class="cov0" title="0">{
                        content.Order = 1
                        content.CreatedAt = now
                        content.UpdatedAt = now
                        if content.ID == uuid.Nil </span><span class="cov0" title="0">{
                                content.ID = uuid.New()
                        }</span>
                        <span class="cov0" title="0">insertQuery := `
                INSERT INTO contents (
                    id, lesson_id, type, order_num, text, object_key, quiz_json, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            `
                        _, err = r.db.Exec(ctx, insertQuery,
                                content.ID, content.LessonID, content.Type, content.Order,
                                content.Text, content.ObjectKey, content.QuizJSON,
                                content.CreatedAt, content.UpdatedAt,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return &amp;content, nil</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">updateQuery := `
        UPDATE contents SET type = $1, text = $2, object_key = $3, quiz_json = $4, updated_at = $5
        WHERE lesson_id = $6
    `
        _, err = r.db.Exec(ctx, updateQuery,
                content.Type, content.Text, content.ObjectKey, content.QuizJSON,
                now, content.LessonID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">content.ID = existingID
        content.UpdatedAt = now
        return &amp;content, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package postgres

import (
        "context"
        "fmt"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/pkg/errors"
)

type Storage struct {
        Pool *pgxpool.Pool
}

func NewPostgresPool(username, password, host, port, dbName string) (*Storage, error) <span class="cov0" title="0">{
        connStr := fmt.Sprintf("postgres://%s:%s@%s:%s/%s", username, password, host, port, dbName)
        pool, err := pgxpool.New(context.Background(), connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to postgres: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Storage{Pool: pool}, nil</span>
}

func (p *Storage) Close() <span class="cov0" title="0">{
        if p.Pool != nil </span><span class="cov0" title="0">{
                p.Pool.Close()
        }</span>
}

func UnwrapPgError(err error) *pgconn.PgError <span class="cov8" title="1">{
        for err != nil </span><span class="cov8" title="1">{
                if pgErr, ok := err.(*pgconn.PgError); ok </span><span class="cov8" title="1">{
                        return pgErr
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package postgres

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

type SubscriptionPostgres struct {
        db *pgxpool.Pool
}

func NewSubscriptionPostgres(db *pgxpool.Pool) *SubscriptionPostgres <span class="cov0" title="0">{
        return &amp;SubscriptionPostgres{db: db}
}</span>

func (r *SubscriptionPostgres) SubscribeCourse(ctx context.Context, courseID, userID uuid.UUID) error <span class="cov0" title="0">{
        now := time.Now().UTC()
        query := `
        INSERT INTO course_subscriptions (course_id, user_id, created_at)
        VALUES ($1, $2, $3)
    `
        _, err := r.db.Exec(ctx, query, courseID, userID, now)
        if err != nil </span><span class="cov0" title="0">{
                if pgErr := UnwrapPgError(err); pgErr != nil &amp;&amp; pgErr.Code == "23505" </span><span class="cov0" title="0">{
                        return app_errors.ErrAlreadySubscribed
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to subscribe: %w", err)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *SubscriptionPostgres) GetSubscribedCourses(ctx context.Context, userID uuid.UUID) ([]models.Course, error) <span class="cov0" title="0">{
        query := `
        SELECT c.id, c.title, c.description, c.logo_object_key, c.created_at, c.updated_at, c.author_id, c.status, c.stars_count
        FROM courses c
        INNER JOIN course_subscriptions cs ON cs.course_id = c.id
        WHERE cs.user_id = $1
        ORDER BY c.created_at DESC
    `
        rows, err := r.db.Query(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query subscribed courses: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var courses []models.Course
        for rows.Next() </span><span class="cov0" title="0">{
                var c models.Course
                if err := rows.Scan(&amp;c.ID, &amp;c.Title, &amp;c.Description, &amp;c.LogoObjectKey, &amp;c.CreatedAt, &amp;c.UpdatedAt, &amp;c.AuthorID, &amp;c.Status, &amp;c.StarsCount); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">courses = append(courses, c)</span>
        }
        <span class="cov0" title="0">return courses, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package postgres

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "context"
        "crypto/sha256"
        "encoding/base64"
        "errors"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "time"
)

type TokensPostgres struct {
        db *pgxpool.Pool
}

func NewTokensPostgres(db *pgxpool.Pool) *TokensPostgres <span class="cov8" title="1">{
        return &amp;TokensPostgres{db: db}
}</span>

func (r *TokensPostgres) hashToken(token *jwt.Token) (string, error) <span class="cov8" title="1">{
        h := sha256.New()
        h.Write([]byte(token.Raw))
        hashedBytes := h.Sum(nil)
        base64TokenHash := base64.StdEncoding.EncodeToString(hashedBytes)
        return base64TokenHash, nil
}</span>

func (r *TokensPostgres) Create(ctx context.Context, userID uuid.UUID, token *jwt.Token) (*models.RefreshToken, error) <span class="cov8" title="1">{
        hashedToken, err := r.hashToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">expiresAt, err := token.Claims.GetExpirationTime()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">expiresAtFormat := expiresAt.Format(time.RFC3339)
        query := `
                INSERT INTO refresh_tokens (user_id, hashed_token, expires_at)
                VALUES ($1, $2, $3)
                RETURNING created_at, expires_at
        `
        refreshToken := &amp;models.RefreshToken{
                UserID:      userID,
                HashedToken: hashedToken,
        }
        err = r.db.QueryRow(ctx, query, userID, hashedToken, expiresAtFormat).Scan(&amp;refreshToken.CreatedAt, &amp;refreshToken.ExpiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return refreshToken, nil</span>
}

func (r *TokensPostgres) ByPrimaryKey(ctx context.Context, userID uuid.UUID, token *jwt.Token) (*models.RefreshToken, error) <span class="cov8" title="1">{
        hashedToken, err := r.hashToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">query := `SELECT * FROM refresh_tokens WHERE user_id = $1 AND hashed_token = $2`
        refreshToken := models.RefreshToken{}
        err = r.db.QueryRow(ctx, query, userID, hashedToken).Scan(&amp;refreshToken.UserID, &amp;refreshToken.HashedToken, &amp;refreshToken.CreatedAt, &amp;refreshToken.ExpiresAt)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, app_errors.ErrTokenNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;refreshToken, nil</span>
}

func (r *TokensPostgres) DeleteUserTokens(ctx context.Context, userID uuid.UUID) error <span class="cov8" title="1">{
        query := `DELETE FROM refresh_tokens WHERE user_id = $1`
        _, err := r.db.Exec(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package postgres

import (
        "SkillForge/internal/app_errors"
        "SkillForge/internal/models"
        "context"
        "errors"
        "fmt"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type UserPostgres struct {
        db *pgxpool.Pool
}

func NewUserPostgres(db *pgxpool.Pool) *UserPostgres <span class="cov0" title="0">{
        return &amp;UserPostgres{db: db}
}</span>

func (r *UserPostgres) UserByID(ctx context.Context, id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT u.id, u.username, u.password, u.email, array_agg(r.name)
                FROM users u
                LEFT JOIN user_roles ur ON u.id = ur.user_id
                LEFT JOIN roles r ON ur.role_id = r.id
                WHERE u.id = $1
                GROUP BY u.id
        `

        row := r.db.QueryRow(ctx, query, id)
        var user models.User
        var roles []string

        err := row.Scan(&amp;user.ID, &amp;user.Username, &amp;user.Password, &amp;user.Email, &amp;roles)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, app_errors.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">user.Roles = roles
        return &amp;user, nil</span>
}

func (r *UserPostgres) UserByName(ctx context.Context, name string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT u.id, u.username, u.password, u.email, array_agg(r.name)
                FROM users u
                LEFT JOIN user_roles ur ON u.id = ur.user_id
                LEFT JOIN roles r ON ur.role_id = r.id
                WHERE u.username = $1
                GROUP BY u.id
        `

        row := r.db.QueryRow(ctx, query, name)
        var user models.User
        var roles []string

        err := row.Scan(&amp;user.ID, &amp;user.Username, &amp;user.Password, &amp;user.Email, &amp;roles)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, app_errors.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">user.Roles = roles
        return &amp;user, nil</span>
}

func (r *UserPostgres) CreateUser(ctx context.Context, user models.User) (*models.User, error) <span class="cov0" title="0">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback(ctx)
                }</span>
        }()

        <span class="cov0" title="0">queryUser := `INSERT INTO users (username, password, email) VALUES ($1, $2, $3) RETURNING id`
        var userID uuid.UUID
        err = tx.QueryRow(ctx, queryUser, user.Username, user.Password, user.Email).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                var pgErr *pgconn.PgError
                if ok := (errors.As(err, &amp;pgErr)); ok &amp;&amp; pgErr.Code == "23505" </span><span class="cov0" title="0">{
                        return nil, app_errors.ErrUserExists
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert user: %w", err)</span>
        }
        <span class="cov0" title="0">user.ID = userID

        queryRole := `SELECT id FROM roles WHERE name = $1`
        insertUserRole := `INSERT INTO user_roles (user_id, role_id) VALUES ($1, $2)`
        for _, roleName := range user.Roles </span><span class="cov0" title="0">{
                var roleID int
                if err = tx.QueryRow(ctx, queryRole, roleName).Scan(&amp;roleID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if _, err = tx.Exec(ctx, insertUserRole, userID, roleID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package json

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"
        "unicode"
)

type JSONSerializer struct{}

func New() *JSONSerializer <span class="cov8" title="1">{
        return &amp;JSONSerializer{}
}</span>

type tokenType int

const (
        tokenEOF tokenType = iota
        tokenString
        tokenNumber
        tokenTrue
        tokenFalse
        tokenNull
        tokenLeftBrace
        tokenRightBrace
        tokenLeftBracket
        tokenRightBracket
        tokenComma
        tokenColon
)

type token struct {
        typ   tokenType
        value string
}

type lexer struct {
        input string
        pos   int
}

func newLexer(input string) *lexer <span class="cov8" title="1">{
        return &amp;lexer{input: input}
}</span>

func (l *lexer) next() token <span class="cov8" title="1">{
        l.skipWhitespace()

        if l.pos &gt;= len(l.input) </span><span class="cov8" title="1">{
                return token{typ: tokenEOF}
        }</span>

        <span class="cov8" title="1">switch c := l.input[l.pos]; c </span>{
        case '{':<span class="cov8" title="1">
                l.pos++
                return token{typ: tokenLeftBrace, value: "{"}</span>
        case '}':<span class="cov8" title="1">
                l.pos++
                return token{typ: tokenRightBrace, value: "}"}</span>
        case '[':<span class="cov0" title="0">
                l.pos++
                return token{typ: tokenLeftBracket, value: "["}</span>
        case ']':<span class="cov0" title="0">
                l.pos++
                return token{typ: tokenRightBracket, value: "]"}</span>
        case ',':<span class="cov8" title="1">
                l.pos++
                return token{typ: tokenComma, value: ","}</span>
        case ':':<span class="cov8" title="1">
                l.pos++
                return token{typ: tokenColon, value: ":"}</span>
        case '"':<span class="cov8" title="1">
                return l.readString()</span>
        case 't':<span class="cov8" title="1">
                if l.pos+3 &lt; len(l.input) &amp;&amp; l.input[l.pos:l.pos+4] == "true" </span><span class="cov8" title="1">{
                        l.pos += 4
                        return token{typ: tokenTrue, value: "true"}
                }</span>
        case 'f':<span class="cov8" title="1">
                if l.pos+4 &lt; len(l.input) &amp;&amp; l.input[l.pos:l.pos+5] == "false" </span><span class="cov8" title="1">{
                        l.pos += 5
                        return token{typ: tokenFalse, value: "false"}
                }</span>
        case 'n':<span class="cov8" title="1">
                if l.pos+3 &lt; len(l.input) &amp;&amp; l.input[l.pos:l.pos+4] == "null" </span><span class="cov8" title="1">{
                        l.pos += 4
                        return token{typ: tokenNull, value: "null"}
                }</span>
        }

        <span class="cov8" title="1">if c := l.input[l.pos]; c == '-' || unicode.IsDigit(rune(c)) </span><span class="cov8" title="1">{
                return l.readNumber()
        }</span>

        <span class="cov0" title="0">return token{typ: tokenEOF}</span>
}

func (l *lexer) skipWhitespace() <span class="cov8" title="1">{
        for l.pos &lt; len(l.input) &amp;&amp; unicode.IsSpace(rune(l.input[l.pos])) </span><span class="cov0" title="0">{
                l.pos++
        }</span>
}

func (s *JSONSerializer) Marshal(v any) ([]byte, error) <span class="cov8" title="1">{
        return s.marshalValue(reflect.ValueOf(v))
}</span>

func (s *JSONSerializer) marshalValue(v reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                return []byte(`"` + escapeString(v.String()) + `"`), nil</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return []byte(strconv.FormatInt(v.Int(), 10)), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return []byte(strconv.FormatUint(v.Uint(), 10)), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return []byte(strconv.FormatFloat(v.Float(), 'f', -1, 64)), nil</span>
        case reflect.Bool:<span class="cov8" title="1">
                return []byte(strconv.FormatBool(v.Bool())), nil</span>
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                return s.marshalArray(v)</span>
        case reflect.Map:<span class="cov8" title="1">
                return s.marshalMap(v)</span>
        case reflect.Struct:<span class="cov8" title="1">
                if v.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov8" title="1">{
                        t := v.Interface().(time.Time)
                        return []byte(`"` + t.Format(time.RFC3339) + `"`), nil
                }</span>
                <span class="cov8" title="1">return s.marshalStruct(v)</span>
        case reflect.Ptr:<span class="cov8" title="1">
                if v.IsNil() </span><span class="cov8" title="1">{
                        return []byte("null"), nil
                }</span>
                <span class="cov8" title="1">return s.marshalValue(v.Elem())</span>
        case reflect.Interface:<span class="cov8" title="1">
                if v.IsNil() </span><span class="cov0" title="0">{
                        return []byte("null"), nil
                }</span>
                <span class="cov8" title="1">return s.marshalValue(v.Elem())</span>
        case reflect.Invalid:<span class="cov0" title="0">
                return []byte("null"), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported type: %v", v.Kind())</span>
        }
}

func (s *JSONSerializer) marshalArray(v reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        if v.IsNil() </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>

        <span class="cov8" title="1">var elements []string
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                element, err := s.marshalValue(v.Index(i))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">elements = append(elements, string(element))</span>
        }
        <span class="cov8" title="1">return []byte("[" + strings.Join(elements, ",") + "]"), nil</span>
}

func (s *JSONSerializer) marshalMap(v reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        if v.IsNil() </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>

        <span class="cov8" title="1">var pairs []string
        iter := v.MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                key := iter.Key()
                value := iter.Value()

                keyBytes, err := s.marshalValue(key)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">valueBytes, err := s.marshalValue(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">pairs = append(pairs, string(keyBytes)+":"+string(valueBytes))</span>
        }
        <span class="cov8" title="1">return []byte("{" + strings.Join(pairs, ",") + "}"), nil</span>
}

func (s *JSONSerializer) marshalStruct(v reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        var pairs []string
        t := v.Type()

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                field := t.Field(i)
                value := v.Field(i)

                if !field.IsExported() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">jsonTag := field.Tag.Get("json")
                if jsonTag == "-" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">omitEmpty := false
                if jsonTag != "" </span><span class="cov8" title="1">{
                        parts := strings.Split(jsonTag, ",")
                        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                for _, part := range parts[1:] </span><span class="cov8" title="1">{
                                        if part == "omitempty" </span><span class="cov8" title="1">{
                                                omitEmpty = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">jsonTag = parts[0]</span>
                }

                <span class="cov8" title="1">if omitEmpty </span><span class="cov8" title="1">{
                        switch value.Kind() </span>{
                        case reflect.String:<span class="cov8" title="1">
                                if value.String() == "" </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                        case reflect.Slice, reflect.Map, reflect.Ptr, reflect.Interface:<span class="cov8" title="1">
                                if value.IsNil() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                                if value.Int() == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                                if value.Uint() == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                                if value.Float() == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        case reflect.Bool:<span class="cov0" title="0">
                                if !value.Bool() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                }

                <span class="cov8" title="1">name := field.Name
                if jsonTag != "" </span><span class="cov8" title="1">{
                        name = jsonTag
                }</span>

                <span class="cov8" title="1">valueBytes, err := s.marshalValue(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">pairs = append(pairs, `"`+name+`":`+string(valueBytes))</span>
        }
        <span class="cov8" title="1">return []byte("{" + strings.Join(pairs, ",") + "}"), nil</span>
}

func escapeString(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, `\`, `\\`)
        s = strings.ReplaceAll(s, `"`, `\"`)
        s = strings.ReplaceAll(s, "\n", `\n`)
        s = strings.ReplaceAll(s, "\r", `\r`)
        s = strings.ReplaceAll(s, "\t", `\t`)
        return s
}</span>

func (l *lexer) readString() token <span class="cov8" title="1">{
        start := l.pos
        l.pos++

        for l.pos &lt; len(l.input) </span><span class="cov8" title="1">{
                c := l.input[l.pos]
                if c == '"' &amp;&amp; l.input[l.pos-1] != '\\' </span><span class="cov8" title="1">{
                        l.pos++
                        return token{typ: tokenString, value: l.input[start+1 : l.pos-1]}
                }</span>
                <span class="cov8" title="1">l.pos++</span>
        }

        <span class="cov0" title="0">return token{typ: tokenEOF}</span>
}

func (l *lexer) readNumber() token <span class="cov8" title="1">{
        start := l.pos
        for l.pos &lt; len(l.input) </span><span class="cov8" title="1">{
                c := l.input[l.pos]
                if !unicode.IsDigit(rune(c)) &amp;&amp; c != '.' &amp;&amp; c != '-' &amp;&amp; c != 'e' &amp;&amp; c != 'E' &amp;&amp; c != '+' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">l.pos++</span>
        }
        <span class="cov8" title="1">return token{typ: tokenNumber, value: l.input[start:l.pos]}</span>
}

type parser struct {
        lexer *lexer
        token token
}

func newParser(input string) *parser <span class="cov8" title="1">{
        lexer := newLexer(input)
        return &amp;parser{
                lexer: lexer,
                token: lexer.next(),
        }
}</span>

func (p *parser) next() <span class="cov8" title="1">{
        p.token = p.lexer.next()
}</span>

func (p *parser) parseValue() (interface{}, error) <span class="cov8" title="1">{
        switch p.token.typ </span>{
        case tokenString:<span class="cov8" title="1">
                val := p.token.value
                p.next()
                return val, nil</span>
        case tokenNumber:<span class="cov8" title="1">
                val := p.token.value
                p.next()
                if strings.Contains(val, ".") </span><span class="cov8" title="1">{
                        f, err := strconv.ParseFloat(val, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return f, nil</span>
                }
                <span class="cov8" title="1">i, err := strconv.ParseInt(val, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return i, nil</span>
        case tokenTrue:<span class="cov8" title="1">
                p.next()
                return true, nil</span>
        case tokenFalse:<span class="cov8" title="1">
                p.next()
                return false, nil</span>
        case tokenNull:<span class="cov8" title="1">
                p.next()
                return nil, nil</span>
        case tokenLeftBrace:<span class="cov8" title="1">
                return p.parseObject()</span>
        case tokenLeftBracket:<span class="cov0" title="0">
                return p.parseArray()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unexpected token: %v", p.token)</span>
        }
}

func (p *parser) parseObject() (map[string]interface{}, error) <span class="cov8" title="1">{
        obj := make(map[string]interface{})
        p.next()

        if p.token.typ == tokenRightBrace </span><span class="cov0" title="0">{
                p.next()
                return obj, nil
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if p.token.typ != tokenString </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected string key, got %v", p.token)
                }</span>
                <span class="cov8" title="1">key := p.token.value
                p.next()

                if p.token.typ != tokenColon </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected colon, got %v", p.token)
                }</span>
                <span class="cov8" title="1">p.next()

                value, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">obj[key] = value

                if p.token.typ == tokenRightBrace </span><span class="cov8" title="1">{
                        p.next()
                        return obj, nil
                }</span>

                <span class="cov8" title="1">if p.token.typ != tokenComma </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected comma or }, got %v", p.token)
                }</span>
                <span class="cov8" title="1">p.next()</span>
        }
}

func (p *parser) parseArray() ([]interface{}, error) <span class="cov0" title="0">{
        arr := make([]interface{}, 0)
        p.next() // skip [

        if p.token.typ == tokenRightBracket </span><span class="cov0" title="0">{
                p.next()
                return arr, nil
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                value, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">arr = append(arr, value)

                if p.token.typ == tokenRightBracket </span><span class="cov0" title="0">{
                        p.next()
                        return arr, nil
                }</span>

                <span class="cov0" title="0">if p.token.typ != tokenComma </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected comma or ], got %v", p.token)
                }</span>
                <span class="cov0" title="0">p.next()</span>
        }
}

func (s *JSONSerializer) Unmarshal(data []byte, v any) error <span class="cov8" title="1">{
        parser := newParser(string(data))
        value, err := parser.parseValue()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return fmt.Errorf("v must be a pointer")
        }</span>

        <span class="cov8" title="1">return s.setValue(rv.Elem(), value)</span>
}

func (s *JSONSerializer) setValue(rv reflect.Value, value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                switch rv.Kind() </span>{
                case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                        rv.Set(reflect.Zero(rv.Type()))
                        return nil</span>
                case reflect.String:<span class="cov0" title="0">
                        rv.SetString("")
                        return nil</span>
                case reflect.Bool:<span class="cov0" title="0">
                        rv.SetBool(false)
                        return nil</span>
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        rv.SetInt(0)
                        return nil</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        rv.SetUint(0)
                        return nil</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        rv.SetFloat(0)
                        return nil</span>
                case reflect.Struct:<span class="cov0" title="0">
                        if rv.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                                rv.Set(reflect.Zero(rv.Type()))
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("cannot convert nil to %v", rv.Kind())</span>
        }

        <span class="cov8" title="1">switch rv.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                        rv.SetString(str)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("cannot convert %v to string", value)
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        rv.SetInt(int64(v))</span>
                case int64:<span class="cov8" title="1">
                        rv.SetInt(v)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("cannot convert %v to int", value)</span>
                }
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        rv.SetUint(uint64(v))</span>
                case int64:<span class="cov0" title="0">
                        rv.SetUint(uint64(v))</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("cannot convert %v to uint", value)</span>
                }
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                if f, ok := value.(float64); ok </span><span class="cov8" title="1">{
                        rv.SetFloat(f)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("cannot convert %v to float", value)
                }</span>
        case reflect.Bool:<span class="cov8" title="1">
                if b, ok := value.(bool); ok </span><span class="cov8" title="1">{
                        rv.SetBool(b)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("cannot convert %v to bool", value)
                }</span>
        case reflect.Slice:<span class="cov0" title="0">
                arr, ok := value.([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot convert %v to slice", value)
                }</span>
                <span class="cov0" title="0">rv.Set(reflect.MakeSlice(rv.Type(), len(arr), len(arr)))
                for i, v := range arr </span><span class="cov0" title="0">{
                        if err := s.setValue(rv.Index(i), v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case reflect.Map:<span class="cov8" title="1">
                obj, ok := value.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot convert %v to map", value)
                }</span>
                <span class="cov8" title="1">rv.Set(reflect.MakeMap(rv.Type()))
                for k, v := range obj </span><span class="cov8" title="1">{
                        key := reflect.ValueOf(k)
                        elem := reflect.New(rv.Type().Elem()).Elem()
                        if err := s.setValue(elem, v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">rv.SetMapIndex(key, elem)</span>
                }
        case reflect.Struct:<span class="cov8" title="1">
                if rv.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                t, err := time.Parse(time.RFC3339, str)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">rv.Set(reflect.ValueOf(t))
                                return nil</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("cannot convert %v to time.Time", value)</span>
                }

                <span class="cov8" title="1">obj, ok := value.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot convert %v to struct", value)
                }</span>
                <span class="cov8" title="1">t := rv.Type()
                for i := 0; i &lt; rv.NumField(); i++ </span><span class="cov8" title="1">{
                        field := t.Field(i)
                        if !field.IsExported() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">jsonTag := field.Tag.Get("json")
                        if jsonTag == "-" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">name := field.Name
                        if jsonTag != "" </span><span class="cov8" title="1">{
                                name = strings.Split(jsonTag, ",")[0]
                        }</span>
                        <span class="cov8" title="1">if v, ok := obj[name]; ok </span><span class="cov8" title="1">{
                                if err := s.setValue(rv.Field(i), v); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        case reflect.Ptr:<span class="cov0" title="0">
                if rv.IsNil() </span><span class="cov0" title="0">{
                        rv.Set(reflect.New(rv.Type().Elem()))
                }</span>
                <span class="cov0" title="0">return s.setValue(rv.Elem(), value)</span>
        case reflect.Interface:<span class="cov0" title="0">
                rv.Set(reflect.ValueOf(value))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported type: %v", rv.Kind())</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *JSONSerializer) Format() string <span class="cov8" title="1">{
        return "JSON"
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package toml

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"
        "unicode"
)

type TOMLSerializer struct{}

func New() *TOMLSerializer <span class="cov8" title="1">{
        return &amp;TOMLSerializer{}
}</span>

type tokenType int

const (
        tokenEOF tokenType = iota
        tokenString
        tokenNumber
        tokenTrue
        tokenFalse
        tokenDate
        tokenLeftBracket
        tokenRightBracket
        tokenDot
        tokenEquals
        tokenComma
        tokenNewline
        tokenLeftBrace
        tokenRightBrace
)

type token struct {
        typ   tokenType
        value string
}

type lexer struct {
        input string
        pos   int
        line  int
        col   int
}

func newLexer(input string) *lexer <span class="cov8" title="1">{
        return &amp;lexer{input: input, line: 1, col: 1}
}</span>

func (l *lexer) next() token <span class="cov8" title="1">{
        l.skipWhitespace()

        if l.pos &gt;= len(l.input) </span><span class="cov8" title="1">{
                return token{typ: tokenEOF}
        }</span>

        <span class="cov8" title="1">c := l.input[l.pos]
        switch c </span>{
        case '[':<span class="cov8" title="1">
                l.pos++
                l.col++
                return token{typ: tokenLeftBracket, value: "["}</span>
        case ']':<span class="cov8" title="1">
                l.pos++
                l.col++
                return token{typ: tokenRightBracket, value: "]"}</span>
        case '{':<span class="cov0" title="0">
                l.pos++
                l.col++
                return token{typ: tokenLeftBrace, value: "{"}</span>
        case '}':<span class="cov0" title="0">
                l.pos++
                l.col++
                return token{typ: tokenRightBrace, value: "}"}</span>
        case '.':<span class="cov0" title="0">
                l.pos++
                l.col++
                return token{typ: tokenDot, value: "."}</span>
        case '=':<span class="cov8" title="1">
                l.pos++
                l.col++
                return token{typ: tokenEquals, value: "="}</span>
        case ',':<span class="cov8" title="1">
                l.pos++
                l.col++
                return token{typ: tokenComma, value: ","}</span>
        case '\n':<span class="cov0" title="0">
                l.pos++
                l.line++
                l.col = 1
                return token{typ: tokenNewline, value: "\n"}</span>
        case '#':<span class="cov0" title="0">
                for l.pos &lt; len(l.input) &amp;&amp; l.input[l.pos] != '\n' </span><span class="cov0" title="0">{
                        l.pos++
                        l.col++
                }</span>
                <span class="cov0" title="0">return l.next()</span>
        case '"':<span class="cov8" title="1">
                return l.readString()</span>
        case 't':<span class="cov8" title="1">
                if l.pos+3 &lt; len(l.input) &amp;&amp; l.input[l.pos:l.pos+4] == "true" </span><span class="cov8" title="1">{
                        l.pos += 4
                        l.col += 4
                        return token{typ: tokenTrue, value: "true"}
                }</span>
        case 'f':<span class="cov0" title="0">
                if l.pos+4 &lt; len(l.input) &amp;&amp; l.input[l.pos:l.pos+5] == "false" </span><span class="cov0" title="0">{
                        l.pos += 5
                        l.col += 5
                        return token{typ: tokenFalse, value: "false"}
                }</span>
        }

        <span class="cov8" title="1">if c == '-' || unicode.IsDigit(rune(c)) </span><span class="cov8" title="1">{
                return l.readNumberOrDate()
        }</span>

        <span class="cov8" title="1">if unicode.IsLetter(rune(c)) </span><span class="cov8" title="1">{
                return l.readIdentifier()
        }</span>

        <span class="cov0" title="0">return token{typ: tokenEOF}</span>
}

func (l *lexer) readIdentifier() token <span class="cov8" title="1">{
        start := l.pos
        for l.pos &lt; len(l.input) </span><span class="cov8" title="1">{
                c := rune(l.input[l.pos])
                if !unicode.IsLetter(c) &amp;&amp; !unicode.IsDigit(c) &amp;&amp; c != '_' &amp;&amp; c != '-' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">l.pos++
                l.col++</span>
        }
        <span class="cov8" title="1">return token{typ: tokenString, value: l.input[start:l.pos]}</span>
}

func (l *lexer) skipWhitespace() <span class="cov8" title="1">{
        for l.pos &lt; len(l.input) </span><span class="cov8" title="1">{
                c := l.input[l.pos]
                if c == '\n' </span><span class="cov8" title="1">{
                        l.line++
                        l.col = 1
                        l.pos++
                }</span> else<span class="cov8" title="1"> if unicode.IsSpace(rune(c)) </span><span class="cov8" title="1">{
                        l.pos++
                        l.col++
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }
}

func (l *lexer) readString() token <span class="cov8" title="1">{
        start := l.pos
        l.pos++
        l.col++

        for l.pos &lt; len(l.input) </span><span class="cov8" title="1">{
                c := l.input[l.pos]
                if c == '"' &amp;&amp; l.input[l.pos-1] != '\\' </span><span class="cov8" title="1">{
                        l.pos++
                        l.col++
                        return token{typ: tokenString, value: l.input[start+1 : l.pos-1]}
                }</span>
                <span class="cov8" title="1">if c == '\n' </span><span class="cov0" title="0">{
                        l.line++
                        l.col = 1
                }</span> else<span class="cov8" title="1"> {
                        l.col++
                }</span>
                <span class="cov8" title="1">l.pos++</span>
        }

        <span class="cov0" title="0">return token{typ: tokenEOF}</span>
}

func (l *lexer) readNumberOrDate() token <span class="cov8" title="1">{
        start := l.pos
        isDate := false

        for l.pos &lt; len(l.input) </span><span class="cov8" title="1">{
                c := l.input[l.pos]
                if c == 'T' || c == 'Z' || c == '-' || c == ':' </span><span class="cov0" title="0">{
                        isDate = true
                }</span> else<span class="cov8" title="1"> if !unicode.IsDigit(rune(c)) &amp;&amp; c != '.' &amp;&amp; c != '+' &amp;&amp; c != 'e' &amp;&amp; c != 'E' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">l.pos++
                l.col++</span>
        }

        <span class="cov8" title="1">value := l.input[start:l.pos]
        if isDate </span><span class="cov0" title="0">{
                return token{typ: tokenDate, value: value}
        }</span>
        <span class="cov8" title="1">return token{typ: tokenNumber, value: value}</span>
}

type parser struct {
        lexer *lexer
        token token
}

func newParser(input string) *parser <span class="cov8" title="1">{
        lexer := newLexer(input)
        return &amp;parser{
                lexer: lexer,
                token: lexer.next(),
        }
}</span>

func (p *parser) next() <span class="cov8" title="1">{
        p.token = p.lexer.next()
}</span>

func (p *parser) parseValue() (interface{}, error) <span class="cov8" title="1">{
        switch p.token.typ </span>{
        case tokenString:<span class="cov8" title="1">
                val := p.token.value
                p.next()
                if t, err := time.Parse(time.RFC3339, val); err == nil </span><span class="cov0" title="0">{
                        return t, nil
                }</span>
                <span class="cov8" title="1">return val, nil</span>
        case tokenNumber:<span class="cov8" title="1">
                val := p.token.value
                p.next()
                if strings.Contains(val, ".") </span><span class="cov0" title="0">{
                        f, err := strconv.ParseFloat(val, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return f, nil</span>
                }
                <span class="cov8" title="1">i, err := strconv.ParseInt(val, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return i, nil</span>
        case tokenDate:<span class="cov0" title="0">
                val := p.token.value
                p.next()
                t, err := time.Parse(time.RFC3339, val)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return t, nil</span>
        case tokenTrue:<span class="cov8" title="1">
                p.next()
                return true, nil</span>
        case tokenFalse:<span class="cov0" title="0">
                p.next()
                return false, nil</span>
        case tokenLeftBracket:<span class="cov8" title="1">
                return p.parseArray()</span>
        case tokenLeftBrace:<span class="cov0" title="0">
                return p.parseInlineTable()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unexpected token: %v", p.token)</span>
        }
}

func (p *parser) parseArray() ([]interface{}, error) <span class="cov8" title="1">{
        arr := make([]interface{}, 0)
        p.next() // skip [

        if p.token.typ == tokenRightBracket </span><span class="cov0" title="0">{
                p.next()
                return arr, nil
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                value, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">arr = append(arr, value)

                if p.token.typ == tokenRightBracket </span><span class="cov8" title="1">{
                        p.next()
                        return arr, nil
                }</span>

                <span class="cov8" title="1">if p.token.typ != tokenComma </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected comma or ], got %v", p.token)
                }</span>
                <span class="cov8" title="1">p.next()</span>
        }
}

func (p *parser) parseInlineTable() (map[string]interface{}, error) <span class="cov0" title="0">{
        table := make(map[string]interface{})
        p.next() // skip {

        if p.token.typ == tokenRightBrace </span><span class="cov0" title="0">{
                p.next()
                return table, nil
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if p.token.typ != tokenString </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected string key, got %v", p.token)
                }</span>
                <span class="cov0" title="0">key := p.token.value
                p.next()

                if p.token.typ != tokenEquals </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected =, got %v", p.token)
                }</span>
                <span class="cov0" title="0">p.next()

                value, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">table[key] = value

                if p.token.typ == tokenRightBrace </span><span class="cov0" title="0">{
                        p.next()
                        return table, nil
                }</span>

                <span class="cov0" title="0">if p.token.typ != tokenComma </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected comma or }, got %v", p.token)
                }</span>
                <span class="cov0" title="0">p.next()</span>
        }
}

func (p *parser) parseTable() (map[string]interface{}, error) <span class="cov8" title="1">{
        table := make(map[string]interface{})
        current := table

        for p.token.typ != tokenEOF </span><span class="cov8" title="1">{
                switch p.token.typ </span>{
                case tokenLeftBracket:<span class="cov0" title="0">
                        p.next()
                        path := p.parseTablePath()
                        if p.token.typ != tokenRightBracket </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("expected ], got %v", p.token)
                        }</span>
                        <span class="cov0" title="0">p.next()

                        current = table
                        for i, key := range path[:len(path)-1] </span><span class="cov0" title="0">{
                                if _, exists := current[key]; !exists </span><span class="cov0" title="0">{
                                        current[key] = make(map[string]interface{})
                                }</span>
                                <span class="cov0" title="0">if next, ok := current[key].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        current = next
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("cannot use %s as table, it's already defined as a value", strings.Join(path[:i+1], "."))
                                }</span>
                        }

                        <span class="cov0" title="0">lastKey := path[len(path)-1]
                        if _, exists := current[lastKey]; !exists </span><span class="cov0" title="0">{
                                current[lastKey] = make(map[string]interface{})
                        }</span>
                        <span class="cov0" title="0">current = current[lastKey].(map[string]interface{})</span>

                case tokenString:<span class="cov8" title="1">
                        key := p.token.value
                        p.next()

                        if p.token.typ != tokenEquals </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("expected =, got %v", p.token)
                        }</span>
                        <span class="cov8" title="1">p.next()

                        value, err := p.parseValue()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">current[key] = value

                        for p.token.typ == tokenNewline </span><span class="cov0" title="0">{
                                p.next()
                        }</span>

                case tokenNewline:<span class="cov0" title="0">
                        p.next()
                        current = table</span>

                default:<span class="cov0" title="0">
                        if p.token.typ != tokenEOF </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected token: %v", p.token)
                        }</span>
                }
        }

        <span class="cov8" title="1">return table, nil</span>
}

func (p *parser) parseTablePath() []string <span class="cov0" title="0">{
        var path []string
        for </span><span class="cov0" title="0">{
                if p.token.typ != tokenString </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">path = append(path, p.token.value)
                p.next()

                if p.token.typ != tokenDot </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">p.next()</span>
        }
        <span class="cov0" title="0">return path</span>
}

func (s *TOMLSerializer) Unmarshal(data []byte, v any) error <span class="cov8" title="1">{
        parser := newParser(string(data))
        value, err := parser.parseTable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return fmt.Errorf("v must be a pointer")
        }</span>

        <span class="cov8" title="1">return s.setValue(rv.Elem(), value)</span>
}

func (s *TOMLSerializer) setValue(rv reflect.Value, value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                switch rv.Kind() </span>{
                case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:<span class="cov0" title="0">
                        rv.Set(reflect.Zero(rv.Type()))
                        return nil</span>
                case reflect.String:<span class="cov0" title="0">
                        rv.SetString("")
                        return nil</span>
                case reflect.Bool:<span class="cov0" title="0">
                        rv.SetBool(false)
                        return nil</span>
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        rv.SetInt(0)
                        return nil</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        rv.SetUint(0)
                        return nil</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        rv.SetFloat(0)
                        return nil</span>
                case reflect.Struct:<span class="cov0" title="0">
                        if rv.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                                rv.Set(reflect.Zero(rv.Type()))
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("cannot convert nil to %v", rv.Kind())</span>
        }

        <span class="cov8" title="1">switch rv.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                        rv.SetString(str)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("cannot convert %v to string", value)
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        rv.SetInt(int64(v))</span>
                case int64:<span class="cov8" title="1">
                        rv.SetInt(v)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("cannot convert %v to int", value)</span>
                }
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        rv.SetUint(uint64(v))</span>
                case int64:<span class="cov0" title="0">
                        rv.SetUint(uint64(v))</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("cannot convert %v to uint", value)</span>
                }
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                if f, ok := value.(float64); ok </span><span class="cov0" title="0">{
                        rv.SetFloat(f)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("cannot convert %v to float", value)
                }</span>
        case reflect.Bool:<span class="cov8" title="1">
                if b, ok := value.(bool); ok </span><span class="cov8" title="1">{
                        rv.SetBool(b)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("cannot convert %v to bool", value)
                }</span>
        case reflect.Slice:<span class="cov8" title="1">
                arr, ok := value.([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot convert %v to slice", value)
                }</span>
                <span class="cov8" title="1">rv.Set(reflect.MakeSlice(rv.Type(), len(arr), len(arr)))
                for i, v := range arr </span><span class="cov8" title="1">{
                        if err := s.setValue(rv.Index(i), v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case reflect.Map:<span class="cov0" title="0">
                obj, ok := value.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot convert %v to map", value)
                }</span>
                <span class="cov0" title="0">rv.Set(reflect.MakeMap(rv.Type()))
                for k, v := range obj </span><span class="cov0" title="0">{
                        key := reflect.ValueOf(k)
                        elem := reflect.New(rv.Type().Elem()).Elem()
                        if err := s.setValue(elem, v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">rv.SetMapIndex(key, elem)</span>
                }
        case reflect.Struct:<span class="cov8" title="1">
                if rv.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                t, err := time.Parse(time.RFC3339, str)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">rv.Set(reflect.ValueOf(t))
                                return nil</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("cannot convert %v to time.Time", value)</span>
                }

                <span class="cov8" title="1">obj, ok := value.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot convert %v to struct", value)
                }</span>
                <span class="cov8" title="1">t := rv.Type()
                for i := 0; i &lt; rv.NumField(); i++ </span><span class="cov8" title="1">{
                        field := t.Field(i)
                        if !field.IsExported() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">tomlTag := field.Tag.Get("toml")
                        if tomlTag == "-" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">name := field.Name
                        if tomlTag != "" </span><span class="cov8" title="1">{
                                name = strings.Split(tomlTag, ",")[0]
                        }</span>
                        <span class="cov8" title="1">if v, ok := obj[name]; ok </span><span class="cov8" title="1">{
                                if err := s.setValue(rv.Field(i), v); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        case reflect.Ptr:<span class="cov0" title="0">
                if rv.IsNil() </span><span class="cov0" title="0">{
                        rv.Set(reflect.New(rv.Type().Elem()))
                }</span>
                <span class="cov0" title="0">return s.setValue(rv.Elem(), value)</span>
        case reflect.Interface:<span class="cov0" title="0">
                rv.Set(reflect.ValueOf(value))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported type: %v", rv.Kind())</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *TOMLSerializer) Marshal(v any) ([]byte, error) <span class="cov8" title="1">{
        return s.marshalValue(reflect.ValueOf(v))
}</span>

func (s *TOMLSerializer) marshalValue(v reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                return []byte(`"` + escapeString(v.String()) + `"`), nil</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return []byte(strconv.FormatInt(v.Int(), 10)), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return []byte(strconv.FormatUint(v.Uint(), 10)), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return []byte(strconv.FormatFloat(v.Float(), 'f', -1, 64)), nil</span>
        case reflect.Bool:<span class="cov8" title="1">
                return []byte(strconv.FormatBool(v.Bool())), nil</span>
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                return s.marshalArray(v)</span>
        case reflect.Map:<span class="cov8" title="1">
                return s.marshalMap(v)</span>
        case reflect.Struct:<span class="cov8" title="1">
                if v.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov8" title="1">{
                        t := v.Interface().(time.Time)
                        return []byte(`"` + t.Format(time.RFC3339) + `"`), nil
                }</span>
                <span class="cov8" title="1">return s.marshalStruct(v)</span>
        case reflect.Ptr:<span class="cov0" title="0">
                if v.IsNil() </span><span class="cov0" title="0">{
                        return []byte(""), nil
                }</span>
                <span class="cov0" title="0">return s.marshalValue(v.Elem())</span>
        case reflect.Interface:<span class="cov8" title="1">
                if v.IsNil() </span><span class="cov0" title="0">{
                        return []byte(""), nil
                }</span>

                <span class="cov8" title="1">switch val := v.Interface().(type) </span>{
                case string:<span class="cov8" title="1">
                        return []byte(`"` + escapeString(val) + `"`), nil</span>
                case int:<span class="cov8" title="1">
                        return []byte(strconv.FormatInt(int64(val), 10)), nil</span>
                case int8, int16, int32, int64:<span class="cov0" title="0">
                        return []byte(strconv.FormatInt(reflect.ValueOf(val).Int(), 10)), nil</span>
                case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                        return []byte(strconv.FormatUint(reflect.ValueOf(val).Uint(), 10)), nil</span>
                case float32, float64:<span class="cov0" title="0">
                        return []byte(strconv.FormatFloat(reflect.ValueOf(val).Float(), 'f', -1, 64)), nil</span>
                case bool:<span class="cov0" title="0">
                        return []byte(strconv.FormatBool(val)), nil</span>
                default:<span class="cov0" title="0">
                        return s.marshalValue(v.Elem())</span>
                }
        case reflect.Invalid:<span class="cov0" title="0">
                return []byte(""), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported type: %v", v.Kind())</span>
        }
}

func (s *TOMLSerializer) marshalStruct(v reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        var mainPairs []string
        var nestedTables []string
        t := v.Type()

        orderedFields := []string{"string_field", "integer", "int_field", "float", "float_field", "boolean", "bool_field", "array", "slice_field", "map_field", "string", "nested", "nested_struct", "time_field", "interface_field"}
        fieldMap := make(map[string]string)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                field := t.Field(i)
                value := v.Field(i)

                if !field.IsExported() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">tomlTag := field.Tag.Get("toml")
                if tomlTag == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">omitEmpty := false
                if tomlTag != "" </span><span class="cov8" title="1">{
                        parts := strings.Split(tomlTag, ",")
                        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                for _, part := range parts[1:] </span><span class="cov8" title="1">{
                                        if part == "omitempty" </span><span class="cov8" title="1">{
                                                omitEmpty = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">tomlTag = parts[0]</span>
                }

                <span class="cov8" title="1">if omitEmpty </span><span class="cov8" title="1">{
                        switch value.Kind() </span>{
                        case reflect.String:<span class="cov0" title="0">
                                if value.String() == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        case reflect.Slice, reflect.Map, reflect.Ptr, reflect.Interface:<span class="cov8" title="1">
                                if value.IsNil() </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                                if value.Int() == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                                if value.Uint() == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                                if value.Float() == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        case reflect.Bool:<span class="cov0" title="0">
                                if !value.Bool() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                }

                <span class="cov8" title="1">name := field.Name
                if tomlTag != "" </span><span class="cov8" title="1">{
                        name = tomlTag
                }</span>

                <span class="cov8" title="1">valueBytes, err := s.marshalValue(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if value.Kind() == reflect.Struct &amp;&amp; value.Type() != reflect.TypeOf(time.Time{}) </span><span class="cov8" title="1">{
                        nestedTables = append(nestedTables, "\n["+name+"]\n"+string(valueBytes))
                }</span> else<span class="cov8" title="1"> if value.Kind() == reflect.Ptr &amp;&amp; !value.IsNil() &amp;&amp; value.Elem().Kind() == reflect.Struct &amp;&amp; value.Elem().Type() != reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                        nestedTables = append(nestedTables, "\n["+name+"]\n"+string(valueBytes))
                }</span> else<span class="cov8" title="1"> {
                        fieldMap[name] = string(valueBytes)
                }</span>
        }

        <span class="cov8" title="1">for _, fieldName := range orderedFields </span><span class="cov8" title="1">{
                if val, ok := fieldMap[fieldName]; ok </span><span class="cov0" title="0">{
                        mainPairs = append(mainPairs, fieldName+" = "+val)
                }</span>
        }

        <span class="cov8" title="1">for name, val := range fieldMap </span><span class="cov8" title="1">{
                found := false
                for _, orderedName := range orderedFields </span><span class="cov8" title="1">{
                        if orderedName == name </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        mainPairs = append(mainPairs, name+" = "+val)
                }</span>
        }

        <span class="cov8" title="1">result := strings.Join(mainPairs, "\n")
        if len(nestedTables) &gt; 0 </span><span class="cov8" title="1">{
                if len(mainPairs) &gt; 0 </span><span class="cov8" title="1">{
                        result += "\n"
                }</span>
                <span class="cov8" title="1">result += strings.Join(nestedTables, "")</span>
        }
        <span class="cov8" title="1">return []byte(result), nil</span>
}

func (s *TOMLSerializer) marshalMap(v reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        if v.IsNil() </span><span class="cov0" title="0">{
                return []byte("{}"), nil
        }</span>

        <span class="cov8" title="1">var pairs []string
        iter := v.MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                key := iter.Key()
                value := iter.Value()

                keyStr := key.String()
                valueBytes, err := s.marshalValue(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">pairs = append(pairs, keyStr+" = "+string(valueBytes))</span>
        }
        <span class="cov8" title="1">return []byte("{ " + strings.Join(pairs, ", ") + " }"), nil</span>
}

func (s *TOMLSerializer) marshalArray(v reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        if v.Len() == 0 </span><span class="cov0" title="0">{
                return []byte("[]"), nil
        }</span>

        <span class="cov8" title="1">var elements []string
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                element, err := s.marshalValue(v.Index(i))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">elements = append(elements, string(element))</span>
        }
        <span class="cov8" title="1">return []byte("[" + strings.Join(elements, ", ") + "]"), nil</span>
}

func escapeString(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, `\`, `\\`)
        s = strings.ReplaceAll(s, `"`, `\"`)
        s = strings.ReplaceAll(s, "\n", `\n`)
        s = strings.ReplaceAll(s, "\r", `\r`)
        s = strings.ReplaceAll(s, "\t", `\t`)
        return s
}</span>

func (s *TOMLSerializer) Format() string <span class="cov8" title="1">{
        return "TOML"
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package logger

import (
        "log/slog"
        "os"
)

const (
        envLocal = "local"
        envDev   = "dev"
        envProd  = "prod"
)

type Log interface {
        Debug(message string, args ...interface{})
        Info(message string, args ...interface{})
        Warn(message string, args ...interface{})
        Error(message string, args ...interface{})
        ErrorErr(message string, err error, args ...interface{})
        Fatal(message string, args ...interface{})
        FatalErr(message string, err error, args ...interface{})
}

type Logger struct {
        logger *slog.Logger
}

func New(env string) *Logger <span class="cov0" title="0">{
        var log *slog.Logger

        switch env </span>{
        case envLocal:<span class="cov0" title="0">
                log = slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelDebug}))</span>
        case envDev:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelDebug}),
                )</span>
        case envProd:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelInfo}),
                )</span>
        default:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelInfo}),
                )</span>
        }
        <span class="cov0" title="0">l := &amp;Logger{logger: log}
        return l</span>
}

func (l *Logger) Debug(message string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Debug(message, args...)
}</span>

func (l *Logger) Info(message string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Info(message, args...)
}</span>

func (l *Logger) Warn(message string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Warn(message, args...)
}</span>

func (l *Logger) Error(message string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Error(message, args...)
}</span>

func (l *Logger) Fatal(message string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Error("FATAL: "+message, args...)
        os.Exit(1)
}</span>

func (l *Logger) ErrorErr(message string, err error, args ...any) <span class="cov0" title="0">{
        allArgs := append(args, Err(err))
        l.logger.Error(message, allArgs...)
}</span>

func (l *Logger) FatalErr(message string, err error, args ...any) <span class="cov0" title="0">{
        allArgs := append(args, Err(err))
        l.logger.Error("FATAL: "+message, allArgs...)
        os.Exit(1)
}</span>

func Err(err error) slog.Attr <span class="cov0" title="0">{
        return slog.Attr{
                Key:   "error",
                Value: slog.StringValue(err.Error()),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
